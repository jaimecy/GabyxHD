<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Montajes GabyxHD 2025</title>
    <link rel="stylesheet" href="styles.css">
    <!-- TEMPORALMENTE DESHABILITADO PARA DEBUG -->
    <!-- <script src="security.js"></script> -->
    
    <!-- Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-HDYP4SXL7E"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-HDYP4SXL7E');
    </script>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>
                <span class="title-line-1">Montajes de GabyxHD en 2025</span>
                <span class="title-line-2">a suscriptores</span>
            </h1>
            
            <!-- BOT√ìN DE PRUEBA PARA HOVER -->
        </div>

        <!-- Modal de autenticaci√≥n -->
        <div class="auth-modal" id="auth-modal">
            <div class="auth-content">
                <h3>üîê Autenticaci√≥n Requerida</h3>
                <p>Introduce la contrase√±a para acceder a las funciones avanzadas:</p>
                <input type="password" id="password-input" placeholder="Contrase√±a" class="password-input">
                <div class="auth-buttons">
                    <button id="cancel-auth-btn" class="cancel-btn">Cancelar</button>
                    <button id="login-btn" class="login-btn">Acceder</button>
                </div>
                <div id="auth-message" class="auth-message"></div>
            </div>
        </div>

        <!-- Spinner de carga centrado en la ventana -->
        <div id="loading-overlay" class="loading-overlay">
            <div class="loading-spinner-container">
                <div class="loading-spinner"></div>
                <div class="loading-text">Cargando datos...</div>
            </div>
        </div>

        <div id="loading" class="loading hidden">
            <span class="spinner">‚è≥</span> Cargando datos...
        </div>

        <div id="error" class="error hidden"></div>

        <!-- Informaci√≥n de Estad√≠sticas -->
        <div id="stats-info">
            <h3 class="stats-title">‚ÑπÔ∏è Informaci√≥n de los Montajes</h3>
            <div id="stats-grid" class="stats-grid"></div>
            
            <!-- CONTENEDOR DE BOTONES EN L√çNEA -->
            <div class="buttons-container">
                <div class="monthly-stats-link">
                    <button onclick="scrollToMonthlyStats(); return false;" class="monthly-stats-btn btn-common">üìÖ Estad√≠sticas Mensuales 2025</button>
                </div>
                
                <div class="stats-button-container">
                    <button id="go-to-analysis-btn" class="go-to-analysis-btn btn-common">
                        üìä An√°lisis de Componentes
                    </button>
                    <button id="toggle-automation-btn" class="automation-toggle-btn btn-common hidden">
                        ü§ñ A√±ade un montaje
                    </button>

                </div>
            </div>
        </div>

        <!-- Formulario de Automatizaci√≥n de T√≠tulos de Twitch -->
        <div id="automation-form" class="automation-form hidden">
            <h3 class="automation-title">ü§ñ <strong>A√ëADIR DATOS DE MONTAJE</strong></h3>

            
            <div class="form-group">
                <label for="twitch-title-input">T√≠tulo del Directo de Twitch:</label>
                <textarea 
                    id="twitch-title-input"
                ></textarea>
            </div>
            
                            <div class="form-actions">
                    <button id="extract-info-btn" class="extract-btn btn-common">üîç Analizar datos</button>
                    <button id="clear-form-btn" class="clear-btn btn-common">üóëÔ∏è Limpiar</button>
                    
                </div>
            
            <div id="extraction-results" class="extraction-results hidden">
                <h4>üìã Informaci√≥n Extra√≠da<br><i>(Se pueden editar los datos)</i></h4>
                <div class="results-grid">
                    <div class="result-item">
                        <label>Fecha:</label>
                        <input type="date" id="extracted-date" class="result-value editable">
                    </div>
                    <div class="result-item">
                        <label>Precio:</label>
                        <input type="text" id="extracted-price" class="result-value editable" placeholder="Solo n√∫meros (ej: 3100)">
                    </div>
                    <div class="result-item">
                        <label>Procesador:</label>
                        <input type="text" id="extracted-processor" class="result-value editable" placeholder="Ej: AMD RYZEN 9 9800X3D">
                    </div>
                    <div class="result-item">
                        <label>Tarjeta Gr√°fica:</label>
                        <input type="text" id="extracted-graphics" class="result-value editable" placeholder="Ej: NVIDIA RTX 5070 TI">
                    </div>
                    <div class="result-item">
                        <label>Torre:</label>
                        <input type="text" id="extracted-case" class="result-value editable" placeholder="Ej: NZXT H9 FLOW">
                    </div>
                </div>
                
                <div class="copy-actions">
                    <button id="add-to-table-btn" class="add-to-table-btn btn-common">‚ûï A√±adir a la Tabla</button>
                </div>
                

            </div>
        </div>

        <!-- NUEVA TABLA CON PROPIEDADES DE COMBINATIONS-TABLE - PARA FIREFOX -->
        <div id="main-table-firefox-container">
            <div class="table-wrapper">
                <div id="main-table-firefox-container-inner"></div>
            </div>
        </div>

        <!-- TABLA VIEJA ELIMINADA - SOLO QUEDA LA NUEVA TABLA -->

        <!-- Secci√≥n de An√°lisis (oculta por defecto) -->
        <div id="analysis-container" class="hidden">
            <div class="back-button-container">
                <button id="back-to-data-btn" class="back-to-data-btn">
                    ‚¨ÖÔ∏è Volver a los Datos
                </button>
            </div>
            <div>
                <!-- Nueva tabla de combinaciones m√°s populares -->
                <div class="combinations-section">
                    <h3 class="combinations-title">üèÜ Top Combinaciones M√°s Populares</h3>
                    <div id="combinations-table-container" class="combinations-table-container"></div>
                </div>
                
                <h2 class="analysis-title">
                    üìä An√°lisis de Componentes Montados
                </h2>
                
                <div id="analysis-content"></div>
            </div>
            
            <!-- Bot√≥n adicional debajo del an√°lisis -->
            <div class="bottom-button-container">
                <button id="back-to-data-btn-bottom" class="back-to-data-btn">
                    ‚¨ÖÔ∏è Volver a los Datos
                </button>
            </div>
        </div>


    </div>

    <script>
        class PCBuildsViewer {
            constructor() {
                this.sheetsData = {};
                // Detecci√≥n autom√°tica de entorno
            this.isLocalEnvironment = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
            this.baseUrl = this.isLocalEnvironment ? 'http://localhost:3000' : 'https://gabyxhd.onrender.com';
            this.apiUrl = `${this.baseUrl}/api/sheets-data`;
            
            console.log(`üåç Entorno detectado: ${this.isLocalEnvironment ? 'LOCAL' : 'PRODUCCI√ìN'}`);
                this.spreadsheetId = '1OCMcUJ0VerXZLEgyjapb_lNvRZQL05lIcGf882AaTfU';
                this.maxRetries = 3;
                this.retryDelay = 2000; // 2 segundos inicial
                this.isAuthenticated = false; // Estado de autenticaci√≥n
                this.init();
            }

            async init() {
                try {
                    // Mostrar spinner de carga inmediatamente
                    this.showLoading('Inicializando aplicaci√≥n...');
                    
                    this.setupEventListeners();
                    this.initAuth(); // Inicializar sistema de autenticaci√≥n
                    
                    // Cargar datos desde el backend real
                    await this.loadDataFromBackend();
                    
                    this.hideLoading();
                    
                    // Ocultar elementos que requieren autenticaci√≥n
                    this.hideAdvancedFeatures();
                    
                } catch (error) {
                    this.showError('Error al inicializar: ' + error.message);
                    this.hideLoading();
                }
            }

            // NUEVA FUNCI√ìN: Ordenar tabla por fecha decreciente
            sortTableByDateDescending() {
                if (!this.sheetsData['Datos'] || this.sheetsData['Datos'].length < 2) return;
                
                const headers = this.sheetsData['Datos'][0];
                const rows = this.sheetsData['Datos'].slice(1);
                
                // Ordenar filas por fecha (columna 0) en orden decreciente
                const sortedRows = rows.sort((a, b) => {
                    const dateA = new Date(a[0]);
                    const dateB = new Date(b[0]);
                    return dateB - dateA; // Orden decreciente (m√°s reciente primero)
                });
                
                // Actualizar los datos con el orden correcto
                this.sheetsData['Datos'] = [headers, ...sortedRows];
                
                // Actualizar indicadores visuales para mostrar que est√° ordenado por fecha decreciente
                this.updateSortIndicators(0, 'desc');
  
            }

            // NUEVA FUNCI√ìN: Cargar datos desde el backend
            async loadDataFromBackend() {
                try {
    
                    this.showLoading('üîÑ Conectando con el servidor...');
                    
                    const response = await fetch(this.getApiUrl('/api/sheets-data'));
                    
                    if (!response.ok) {
                        throw new Error(`Error del servidor: ${response.status}`);
                    }
                    
                    this.showLoading('üìä Procesando datos del servidor...');
                    
                    const result = await response.json();
                    
                    if (!result.success) {
                        throw new Error(result.error || 'Error al cargar datos');
                    }
                    
                    this.showLoading('üîÑ Organizando y ordenando datos...');
                    
                    // Estructurar datos como antes
                    this.sheetsData = {
                        'Datos': [result.headers, ...result.data]
                    };
                    
    
                    
                    // Ordenar por fecha decreciente por defecto
                    this.sortTableByDateDescending();
                    
                    this.showLoading('üìã Generando tabla y estad√≠sticas...');
                    
                    // Mostrar la tabla principal (ya ordenada)
                    this.displaySheetData('Datos');
                    
                    // Actualizar indicadores visuales DESPU√âS de renderizar la tabla
                    this.updateSortIndicators(0, 'desc');
                    
                    // Generar estad√≠sticas b√°sicas
                    this.displayStats();
                    
                    // Ocultar spinner cuando todo est√© listo
                    this.hideLoading();
                    
                } catch (error) {
                    console.error('‚ùå Error al cargar datos del backend:', error);
                    
                    this.showLoading('‚ö†Ô∏è Error de conexi√≥n, usando datos locales...');
                    
                    // Fallback: usar datos est√°ticos si falla el backend
    
                    this.sheetsData = {
                        'Datos': [
                            ['Fecha', 'T√≠tulo del directo de Twitch', 'Precio ‚Ç¨', 'Procesador', 'Tarjeta gr√°fica', 'Torre'],
                            ['2025-08-28', 'Montaje PC 2950‚Ç¨ Invertido - 9800X3D & RTX 5080 & BeQuiet 600 LX', '2950', 'AMD RYZEN 9 9800X3D', 'NVIDIA RTX 5080', 'BEQUIET 600 LX']
                        ]
                    };
                    
                    this.displaySheetData('Datos');
                    
                    // Actualizar indicadores visuales tambi√©n en el fallback
                    this.updateSortIndicators(0, 'desc');
                    
                    this.displayStats();
                    
                    // Ocultar spinner en caso de fallback
                    this.hideLoading();
                    
                    this.showError('Error al conectar con el backend. Usando datos locales.');
                }
            }

            // DESHABILITADO - No se necesita conectividad en modo offline
            /*
            async checkConnectivityWithRetry() {
                let lastError;
                
                for (let attempt = 1; attempt <= this.maxRetries; attempt++) {
                    try {
                        this.showLoading(`Verificando conectividad... (intento ${attempt}/${this.maxRetries})`);
                        
                        // Intentar hacer ping al servidor con timeout m√°s largo
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), 15000); // 15 segundos
                        
                        const response = await fetch(this.apiUrl + '?ping=true', {
                            signal: controller.signal,
                            method: 'HEAD'
                        });
                        
                        clearTimeout(timeoutId);
                        
                        if (!response.ok) {
                            throw new Error(`Servidor respondi√≥ con estado: ${response.status}`);
                        }
                        
                        return true;
                    } catch (error) {
                        lastError = error;
                        
                        if (error.name === 'AbortError') {
                            console.warn(`Timeout en intento ${attempt}/${this.maxRetries}`);
                            
                            if (attempt < this.maxRetries) {
                                // Esperar antes del siguiente intento con backoff exponencial
                                const delay = this.retryDelay * Math.pow(2, attempt - 1);
                                this.showLoading(`Timeout. Reintentando en ${Math.round(delay/1000)}s... (${attempt}/${this.maxRetries})`);
                                await new Promise(resolve => setTimeout(resolve, delay));
                            }
                        } else {
                            // Error de red u otro tipo
                            if (attempt < this.maxRetries) {
                                const delay = this.retryDelay * Math.pow(2, attempt - 1);
                                this.showLoading(`Error de conexi√≥n. Reintentando en ${Math.round(delay/1000)}s... (${attempt}/${this.maxRetries})`);
                                await new Promise(resolve => setTimeout(resolve, delay));
                            }
                        }
                    }
                }
                
                // Si llegamos aqu√≠, todos los intentos fallaron
                if (lastError.name === 'AbortError') {
                    throw new Error('El servidor no responde despu√©s de m√∫ltiples intentos (timeout)');
                } else {
                    throw new Error('No se puede conectar al servidor despu√©s de m√∫ltiples intentos: ' + lastError.message);
                }
            }
            */

            // DESHABILITADO - No se necesita conectividad en modo offline
            /*
            async checkConnectivity() {
                try {
                    // Intentar hacer ping al servidor
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 15000); // Aumentado a 15 segundos
                    
                    const response = await fetch(this.apiUrl + '?ping=true', {
                        signal: controller.signal,
                        method: 'HEAD'
                    });
                    
                    clearTimeout(timeoutId);
                    
                    if (!response.ok) {
                        throw new Error(`Servidor respondi√≥ con estado: ${response.status}`);
                    }
                    
                    return true;
                } catch (error) {
                    if (error.name === 'AbortError') {
                        throw new Error('El servidor no responde (timeout)');
                    }
                    throw new Error('No se puede conectar al servidor: ' + error.message);
                }
            }
            */

            // DESHABILITADO - No se necesita en modo offline
            /*
            showRetryButton() {
                const errorDiv = document.getElementById('error');
                if (errorDiv) {
                    errorDiv.innerHTML = `
                        <div class="error-content">
                            <p>‚ùå ${errorDiv.textContent}</p>
                            <div class="error-actions">
                                <button onclick="location.reload()" class="retry-button">
                                    üîÑ Reintentar
                                </button>
                                <button onclick="window.pcBuildsViewer.checkServerStatus()" class="status-button">
                                    üìä Estado del Servidor
                                </button>
                                <button onclick="window.pcBuildsViewer.checkConnectivityManually()" class="connectivity-button">
                                    üåê Verificar Conexi√≥n
                                </button>
                            </div>
                            <div class="error-tips">
                                <p><strong>üí° Consejos:</strong></p>
                                <ul>
                                    <li>Verifica tu conexi√≥n a internet</li>
                                    <li>El servidor puede estar temporalmente lento</li>
                                    <li>Intenta recargar la p√°gina en unos minutos</li>
                                </ul>
                            </div>
                        </div>
                    `;
                }
            }
            */

            async checkConnectivityManually() {
                try {
                    this.showLoading('Verificando conectividad manualmente...');
                    
                    const startTime = Date.now();
                    const response = await fetch(this.getApiUrl('/health'), {
                        method: 'GET',
                        signal: AbortSignal.timeout(20000) // 20 segundos para verificaci√≥n manual
                    });
                    
                    const endTime = Date.now();
                    const responseTime = endTime - startTime;
                    
                    if (response.ok) {
                        const health = await response.json();
                        this.showError(`‚úÖ Servidor funcionando - Tiempo de respuesta: ${responseTime}ms - Uptime: ${Math.round(health.uptime / 60)} minutos`);
                    } else {
                        this.showError(`‚ö†Ô∏è Servidor respondi√≥ con estado: ${response.status} - Tiempo: ${responseTime}ms`);
                    }
                } catch (error) {
                    if (error.name === 'TimeoutError') {
                        this.showError(`‚ùå Timeout despu√©s de 20 segundos - El servidor est√° muy lento o no responde`);
                    } else {
                        this.showError(`‚ùå Error de conexi√≥n: ${error.message}`);
                    }
                } finally {
                    this.hideLoading();
                }
            }

            // DESHABILITADO - No se necesita en modo offline
            async checkServerStatus() {
                try {
                    this.showLoading('Verificando estado del servidor...');
                    
                    const startTime = Date.now();
                    const response = await fetch(this.getApiUrl('/health'), {
                        method: 'GET',
                        signal: AbortSignal.timeout(15000) // 15 segundos
                    });
                    const endTime = Date.now();
                    const responseTime = endTime - startTime;
                    
                    if (response.ok) {
                        const health = await response.json();
                        const uptimeMinutes = Math.round(health.uptime / 60);
                        const uptimeHours = Math.floor(uptimeMinutes / 60);
                        const remainingMinutes = uptimeMinutes % 60;
                        
                        let uptimeText = '';
                        if (uptimeHours > 0) {
                            uptimeText = `${uptimeHours}h ${remainingMinutes}m`;
                        } else {
                            uptimeText = `${uptimeMinutes}m`;
                        }
                        
                        this.showError(`‚úÖ Servidor funcionando correctamente

üìä Informaci√≥n del servidor:
‚Ä¢ Tiempo de respuesta: ${responseTime}ms
‚Ä¢ Tiempo activo: ${uptimeText}
‚Ä¢ Estado HTTP: ${response.status}
‚Ä¢ URL: ${this.baseUrl}`);
                    } else {
                        this.showError(`‚ö†Ô∏è Servidor respondi√≥ con estado: ${response.status}

üìä Detalles:
‚Ä¢ Tiempo de respuesta: ${responseTime}ms
‚Ä¢ Estado HTTP: ${response.status}
‚Ä¢ URL: ${this.baseUrl}
‚Ä¢ El servidor est√° respondiendo pero con un error`);
                    }
                } catch (error) {
                    if (error.name === 'TimeoutError') {
                        this.showError(`‚ùå Timeout - El servidor no responde en 15 segundos

üìä Diagn√≥stico:
‚Ä¢ El servidor est√° muy lento o no responde
‚Ä¢ Tiempo m√°ximo de espera: 15 segundos
‚Ä¢ URL: ${this.baseUrl}
‚Ä¢ Posible problema de conectividad o servidor sobrecargado`);
                    } else {
                        this.showError(`‚ùå Error de conexi√≥n: ${error.message}

üìä Diagn√≥stico:
‚Ä¢ Tipo de error: ${error.name || 'Desconocido'}
‚Ä¢ URL: ${this.baseUrl}
‚Ä¢ Posible problema de red o servidor inaccesible`);
                    }
                } finally {
                    this.hideLoading();
                }
            }

            // DESHABILITADO - Google Sheets no disponible en modo offline
            /*
            async loadSheetData(sheetName) {
                let lastError;
                
                for (let attempt = 1; attempt <= this.maxRetries; attempt++) {
                    try {
                        if (attempt > 1) {
                            this.showLoading(`Cargando datos... (intento ${attempt}/${this.maxRetries})`);
                        }
                        
                        const response = await fetch(this.apiUrl, {
                            signal: AbortSignal.timeout(20000) // 20 segundos para cargar datos
                        });
                        
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        
                        const result = await response.json();
                        
                        if (!result.success) {
                            throw new Error(result.error || 'Error al obtener datos');
                        }
                        
                        // Procesar los datos del backend
                        const rows = result.data;
                        const headers = result.headers;
                        
                        if (!rows || rows.length === 0) {
                            throw new Error('No se encontraron datos en la hoja');
                        }
                        
                         // Convertir los datos al formato esperado por el frontend
                         const processedRows = rows.map(row => [
                             row['Fecha'] || '',
                             row['T√≠tulo del directo de Twitch'] || '',
                             row['Precio ‚Ç¨'] || '',
                             row['Procesador'] || '',
                             row['Tarjeta gr√°fica'] || '',
                             row['Torre'] || ''
                         ]);
                        
                        // Filtrar filas con fechas v√°lidas y ordenar por fecha decreciente
                        const validRows = processedRows.filter(row => {
                            const dateStr = row[0].trim();
                            if (!dateStr) return false;
                            
                            // Intentar diferentes formatos de fecha
                            let date = new Date(dateStr);
                            if (isNaN(date.getTime())) {
                                // Si falla, intentar con formato DD-MM-YYYY
                                const parts = dateStr.split('-');
                                if (parts.length === 3) {
                                    date = new Date(parts[2], parts[1] - 1, parts[0]);
                                }
                            }
                            
                            return !isNaN(date.getTime());
                        });
                        
                        const invalidRows = processedRows.filter(row => {
                            const dateStr = row[0].trim();
                            if (!dateStr) return false;
                            
                            let date = new Date(dateStr);
                            if (isNaN(date.getTime())) {
                                const parts = dateStr.split('-');
                                if (parts.length === 3) {
                                    date = new Date(parts[2], parts[1] - 1, parts[0]);
                                }
                            }
                            
                            return isNaN(date.getTime());
                        });
                        
                        // Ordenar filas v√°lidas por fecha decreciente (m√°s reciente primero)
                        validRows.sort((a, b) => {
                            const dateStrA = a[0].trim();
                            const dateStrB = b[0].trim();
                            
                            let dateA = new Date(dateStrA);
                            if (isNaN(dateA.getTime())) {
                                const parts = dateStrA.split('-');
                                if (parts.length === 3) {
                                    dateA = new Date(parts[2], parts[1] - 1, parts[0]);
                                }
                            }
                            
                            let dateB = new Date(dateStrB);
                            if (isNaN(dateB.getTime())) {
                                const parts = dateStrB.split('-');
                                if (parts.length === 3) {
                                    dateB = new Date(parts[2], parts[1] - 1, parts[0]);
                                }
                            }
                            
                            return dateB - dateA; // Orden decreciente
                        });
                        

                        
                        // Agregar filas inv√°lidas al final (sin ordenar)
                        const finalRows = [...validRows, ...invalidRows];
                        
                        // Crear un nuevo array con las filas finales
                        const finalData = [headers, ...finalRows];
                        
                        this.sheetsData[sheetName] = finalData;
                        this.displaySheetData(sheetName);
                        this.displayStats();
                        this.generateAnalysis(finalData);
                        
                        // Cargar entradas locales despu√©s de cargar los datos de Google Sheets
                        this.loadLocalEntries();
                        
                        // Actualizar el contador de entradas locales
                        this.updateLocalEntriesCount();
                        
                        return; // Salir del bucle si todo va bien
                        
                    } catch (error) {
                        lastError = error;
                        
                        if (error.name === 'TimeoutError') {
                            console.warn(`Timeout al cargar datos en intento ${attempt}/${this.maxRetries}`);
                            
                            if (attempt < this.maxRetries) {
                                // Esperar antes del siguiente intento con backoff exponencial
                                const delay = this.retryDelay * Math.pow(2, attempt - 1);
                                this.showLoading(`Timeout al cargar datos. Reintentando en ${Math.round(delay/1000)}s... (${attempt}/${this.maxRetries})`);
                                await new Promise(resolve => setTimeout(resolve, delay));
                            }
                        } else {
                            // Error de red u otro tipo
                            if (attempt < this.maxRetries) {
                                const delay = this.retryDelay * Math.pow(2, attempt - 1);
                                this.showLoading(`Error al cargar datos. Reintentando en ${Math.round(delay/1000)}s... (${attempt}/${this.maxRetries})`);
                                await new Promise(resolve => setTimeout(resolve, delay));
                            }
                        }
                    }
                }
                
                // Si llegamos aqu√≠, todos los intentos fallaron
                throw new Error('Error al cargar datos de la hoja despu√©s de m√∫ltiples intentos: ' + lastError.message);
            }
            */

            generateAnalysis(data) {
                if (!data || data.length < 2) return;
                
                const rows = data.slice(1); // Excluir la fila de headers
                const processors = {};
                const graphics = {};
                const cases = {};
                const combinations = {};

                                 // √çndices de las columnas
                 const priceIndex = 2; // Precio ‚Ç¨
                const processorIndex = 3; // Procesador
                const graphicsIndex = 4; // Tarjeta gr√°fica
                const caseIndex = 5; // Torre

                rows.forEach((row, index) => {
                    // An√°lisis de procesadores
                    const processorItem = row[processorIndex];
                    if (processorItem && processorItem.trim() !== '') {
                        const cleanProcessor = processorItem.trim();
                        processors[cleanProcessor] = (processors[cleanProcessor] || 0) + 1;
                    }

                    // An√°lisis de tarjetas gr√°ficas
                    const graphicsItem = row[graphicsIndex];
                    if (graphicsItem && graphicsItem.trim() !== '') {
                        const cleanGraphics = graphicsItem.trim();
                        graphics[cleanGraphics] = (graphics[cleanGraphics] || 0) + 1;
                    }

                    // An√°lisis de torres
                    const caseItem = row[caseIndex];
                    if (caseItem && caseItem.trim() !== '') {
                        const cleanCase = caseItem.trim();
                        cases[cleanCase] = (cases[cleanCase] || 0) + 1;
                    }

                    // An√°lisis de combinaciones (procesador + gr√°fica + torre)
                    if (processorItem && graphicsItem && caseItem) {
                        const cleanProcessor = processorItem.trim();
                        const cleanGraphics = graphicsItem.trim();
                        const cleanCase = caseItem.trim();
                        
                        if (cleanProcessor && cleanGraphics && cleanCase) {
                            const combinationKey = `${cleanProcessor}|${cleanGraphics}|${cleanCase}`;
                            combinations[combinationKey] = (combinations[combinationKey] || 0) + 1;
                        }
                    }
                });

                // An√°lisis de precios
                const prices = rows.map(row => parseFloat(row[priceIndex])).filter(p => !isNaN(p));
                const avgPrice = prices.length > 0 ? prices.reduce((a, b) => a + b, 0) / prices.length : 0;
                const minPrice = Math.min(...prices);
                const maxPrice = Math.max(...prices);



                this.displayAnalysis(processors, graphics, cases, { avg: avgPrice, min: minPrice, max: maxPrice, total: rows.length });
                this.displayCombinationsTable(combinations);
                
                // Generar estad√≠sticas mensuales
                this.displayMonthlyStats(data);
            }

            displayAnalysis(processors, graphics, cases, prices) {
                // Crear contenido del an√°lisis
                const analysisContent = document.getElementById('analysis-content');
                
                // NO mostrar autom√°ticamente - solo cuando se pulse el bot√≥n
                // document.getElementById('analysis-container').classList.remove('hidden');
                
                analysisContent.innerHTML = `
                    <div class="analysis-grid">
                        <div class="processor-section">
                            <h3 class="section-title">
                                Procesadores
                            </h3>
                            ${this.generateAnalysisTable(processors, 'Procesador', 'processor')}
                        </div>
                        
                        <div class="graphics-section">
                            <h3 class="section-title">
                                Tarjetas Gr√°ficas
                            </h3>
                            ${this.generateAnalysisTable(graphics, 'Tarjeta Gr√°fica', 'graphics')}
                        </div>
                        
                        <div class="tower-section">
                            <h3 class="section-title">
                                Torres
                            </h3>
                            ${this.generateAnalysisTable(cases, 'Torre', 'case')}
                        </div>
                    </div>
                    
                    <div class="prices-section">
                        <h3 class="prices-title">
                            Resumen de Precios de PCs
                        </h3>
                        <div class="prices-grid">
                            <div class="price-card">
                                <div class="price-value price-avg">${Math.round(prices.avg)}‚Ç¨</div>
                                <div class="price-label">Precio Promedio</div>
                            </div>
                            <div class="price-card">
                                <div class="price-value price-min">${prices.min}‚Ç¨</div>
                                <div class="price-label">Precio M√≠nimo</div>
                            </div>
                            <div class="price-card">
                                <div class="price-value price-max">${prices.max}‚Ç¨</div>
                                <div class="price-label">Precio M√°ximo</div>
                            </div>
                        </div>
                    </div>
                `;
            }

            displayCombinationsTable(combinations) {
                const combinationsContainer = document.getElementById('combinations-table-container');
                
                // NO mostrar autom√°ticamente - solo cuando se pulse el bot√≥n
                // document.getElementById('combinations-table-container').classList.remove('hidden');
                
                if (!combinations || Object.keys(combinations).length === 0) {
                    combinationsContainer.innerHTML = '<p class="no-combinations">No hay combinaciones disponibles para mostrar.</p>';
                    return;
                }

                // Convertir combinaciones a array, filtrar las que solo se usaron una vez y ordenar por n√∫mero de veces usado (de mayor a menor)
                const sortedCombinations = Object.entries(combinations)
                    .filter(([, count]) => count > 1) // Solo combinaciones usadas m√°s de una vez
                    .sort(([, countA], [, countB]) => countB - countA)
                    .slice(0, 20); // Mostrar solo las top 20 combinaciones

                let tableHTML = `
                    <div class="analysis-table-container">
                        <table class="combinations-table" style="width: 820px !important; table-layout: fixed !important;">
                            <thead>
                                <tr>
                                    <th style="width: 120px !important; min-width: 120px !important; max-width: 120px !important;">N¬∞ veces</th>
                                    <th style="width: 200px !important; min-width: 200px !important; max-width: 200px !important;">Procesador</th>
                                    <th style="width: 200px !important; min-width: 200px !important; max-width: 200px !important;">Gr√°fica</th>
                                    <th style="width: 300px !important; min-width: 300px !important; max-width: 300px !important;">Torre</th>
                                </tr>
                            </thead>
                            <tbody>
                `;

                sortedCombinations.forEach(([combinationKey, count], index) => {
                    const [processor, graphics, case_] = combinationKey.split('|');
                    const rowClass = index % 2 === 0 ? 'combinations-row combinations-row-even' : 'combinations-row combinations-row-odd';
                    
                    tableHTML += `
                        <tr class="${rowClass}">
                            <td class="combinations-count" style="width: 120px !important; min-width: 120px !important; max-width: 120px !important; text-align: center !important;">${count}</td>
                            <td class="combinations-processor" style="width: 200px !important; min-width: 200px !important; max-width: 200px !important; text-align: center !important;">${processor}</td>
                            <td class="combinations-graphics" style="width: 200px !important; min-width: 200px !important; max-width: 200px !important; text-align: center !important;">${graphics}</td>
                            <td class="combinations-case" style="width: 300px !important; min-width: 300px !important; max-width: 300px !important; text-align: center !important;">${case_}</td>
                        </tr>
                    `;
                });

                tableHTML += '</tbody></table></div>';
                
                combinationsContainer.innerHTML = tableHTML;
            }

            generateAnalysisTable(data, title, type) {
                const sortedData = Object.entries(data)
                    .sort(([nameA, countA], [nameB, countB]) => {
                        if (countB !== countA) {
                            return countB - countA; // Primero por cantidad (de mayor a menor)
                        }
                        return nameA.localeCompare(nameB); // Luego alfab√©ticamente en empates
                    });

                let tableHTML = `
                    <div class="analysis-table-container">
                        <table class="analysis-table">
                            <thead>
                                <tr>
                                    <th>${title}</th>
                                    <th>N¬∞ veces</th>
                                    <th>%</th>
                                </tr>
                            </thead>
                            <tbody>
                `;

                const total = Object.values(data).reduce((sum, count) => sum + count, 0);

                sortedData.forEach(([name, count], index) => {
                    const percentage = ((count / total) * 100).toFixed(1);
                    const rowClass = index % 2 === 0 ? 'analysis-row analysis-row-even' : 'analysis-row analysis-row-odd';
                    
                    tableHTML += `
                        <tr class="${rowClass}">
                            <td>${name}</td>
                            <td>${count}</td>
                            <td>${percentage}%</td>
                        </tr>
                    `;
                });

                tableHTML += '</tbody></table></div>';
                
                // Agregar resumen del total de componentes distintos
                const uniqueComponents = Object.keys(data).length;
                const totalUsage = total;
                
                // Determinar la etiqueta espec√≠fica seg√∫n el tipo de componente
                let componentLabel = 'componentes distintos';
                if (type === 'processor') {
                    componentLabel = 'procesadores distintos';
                } else if (type === 'graphics') {
                    componentLabel = 'tarjetas gr√°ficas distintas';
                } else if (type === 'case') {
                    componentLabel = 'torres distintas';
                }
                
                tableHTML += `
                    <div class="analysis-summary">
                        <span class="analysis-summary-text">${uniqueComponents} ${componentLabel}</span> | 
                        <span class="analysis-summary-text">Cantidad total: ${totalUsage}</span>
                    </div>
                `;
                

                
                return tableHTML;
            }







            setupEventListeners() {
                document.getElementById('go-to-analysis-btn').onclick = () => this.showAnalysis();
                document.getElementById('back-to-data-btn').onclick = () => this.showData();
                document.getElementById('back-to-data-btn-bottom').onclick = () => this.showData(); // Add listener for the new button
                
                // Event listeners para la automatizaci√≥n
                document.getElementById('toggle-automation-btn').onclick = () => this.toggleAutomation();
                document.getElementById('extract-info-btn').onclick = () => this.extractTwitchInfo();
                document.getElementById('clear-form-btn').onclick = () => this.clearAutomationForm();
                document.getElementById('add-to-table-btn').onclick = () => this.addToMainTable();


                
                // Event listeners para campos editables (convertir a may√∫sculas)
                document.getElementById('extracted-processor').addEventListener('input', (e) => {
                    e.target.value = e.target.value.toUpperCase();
                });
                document.getElementById('extracted-graphics').addEventListener('input', (e) => {
                    e.target.value = e.target.value.toUpperCase();
                });
                document.getElementById('extracted-case').addEventListener('input', (e) => {
                    e.target.value = e.target.value.toUpperCase();
                });
                

                
                // Event listener para mostrar/ocultar estad√≠sticas mensuales
                // (Eliminado ya que no es necesario)
            }

            showAnalysis() {
                // Asegurar que el an√°lisis est√© generado
                if (this.sheetsData['Datos'] && this.sheetsData['Datos'].length > 1) {
                    this.generateAnalysis(this.sheetsData['Datos']);
                }
                
                // OCULTAR solo la secci√≥n de datos (la tabla principal)
                document.getElementById('main-table-firefox-container').classList.add('hidden');
                // OCULTAR las estad√≠sticas b√°sicas cuando se muestra el an√°lisis
                document.getElementById('stats-info').classList.add('hidden');
                
                // OCULTAR las estad√≠sticas mensuales
                const monthlyStatsWrapper = document.getElementById('monthly-stats-wrapper');
                if (monthlyStatsWrapper) {
                    monthlyStatsWrapper.classList.add('hidden');
                }
                
                // MOSTRAR SOLO la secci√≥n de an√°lisis
                document.getElementById('analysis-container').style.display = 'block';
                document.getElementById('analysis-container').classList.remove('hidden');
                
                // Desplazarse al inicio de la p√°gina
                setTimeout(() => {
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                }, 100);
                
                // Alternativa si el scroll suave no funciona
                setTimeout(() => {
                    if (window.pageYOffset > 0) {
                        window.scrollTo(0, 0);
                    }
                }, 500);
            }

            showData() {
                // OCULTAR la secci√≥n de an√°lisis
                document.getElementById('analysis-container').style.display = 'none';
                document.getElementById('analysis-container').classList.add('hidden');
                
                // MOSTRAR la secci√≥n de datos y estad√≠sticas
                document.getElementById('main-table-firefox-container').classList.remove('hidden');
                document.getElementById('stats-info').classList.remove('hidden');
                
                // MOSTRAR las estad√≠sticas mensuales
                const monthlyStatsWrapper = document.getElementById('monthly-stats-wrapper');
                if (monthlyStatsWrapper) {
                    monthlyStatsWrapper.classList.remove('hidden');
                }
                
                // Desplazarse arriba del todo - FORZAR el scroll
                setTimeout(() => {
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                }, 100);
                
                // Alternativa si el scroll suave no funciona
                setTimeout(() => {
                    if (window.pageYOffset > 0) {
                        window.scrollTo(0, 0);
                    }
                }, 500);
            }



            showLoading(message) {
                // Mostrar el overlay de carga centrado
                const loadingOverlay = document.getElementById('loading-overlay');
                if (loadingOverlay) {
                    const loadingText = loadingOverlay.querySelector('.loading-text');
                    if (loadingText && message) {
                        loadingText.textContent = message;
                    }
                    loadingOverlay.classList.remove('hidden');
                }
                
                // Tambi√©n mostrar el loading original como respaldo
                document.getElementById('loading').innerHTML = `‚è≥ ${message}`;
                document.getElementById('loading').style.display = 'block';
            }

            hideLoading() {
                // Ocultar el overlay de carga centrado
                const loadingOverlay = document.getElementById('loading-overlay');
                if (loadingOverlay) {
                    loadingOverlay.classList.add('hidden');
                }
                
                // Ocultar el loading original
                document.getElementById('loading').style.display = 'none';
            }

            showError(message) {
                document.getElementById('loading').style.display = 'none';
                document.getElementById('error').textContent = message;
                document.getElementById('error').classList.remove('hidden');
            }

            displayStats() {
                const data = this.sheetsData['Datos'];
                if (!data || data.length < 2) return;

                const totalRows = data.length - 1; // Excluir headers
                const uniqueProcessors = new Set();
                const uniqueGraphics = new Set();
                const uniqueCases = new Set();

                // Contar componentes distintos
                data.slice(1).forEach(row => {
                    if (row[3] && row[3].trim()) uniqueProcessors.add(row[3].trim());
                    if (row[4] && row[4].trim()) uniqueGraphics.add(row[4].trim());
                    if (row[5] && row[5].trim()) uniqueCases.add(row[5].trim());
                });

                const statsGrid = document.getElementById('stats-grid');
                statsGrid.innerHTML = `
                    <div class="stat-card">
                        <div class="number">${totalRows}</div>
                        <div class="label">Montajes</div>
                    </div>
                    <div class="stat-card">
                        <div class="number">${uniqueProcessors.size}</div>
                        <div class="label">Procesadores distintos</div>
                    </div>
                    <div class="stat-card">
                        <div class="number">${uniqueGraphics.size}</div>
                        <div class="label">Tarjetas Gr√°ficas distintas</div>
                    </div>
                    <div class="stat-card">
                        <div class="number">${uniqueCases.size}</div>
                        <div class="label">Torres distintas</div>
                    </div>
                `;

                // Generar estad√≠sticas mensuales
                this.displayMonthlyStats(data);

                document.getElementById('stats-info').classList.remove('hidden');
                document.getElementById('main-table-firefox-container').classList.remove('hidden');
                
                // Mostrar las estad√≠sticas mensuales
                const monthlyStatsWrapper = document.getElementById('monthly-stats-wrapper');
                if (monthlyStatsWrapper) {
                    monthlyStatsWrapper.classList.remove('hidden');
    
                }
            }

            displaySheetData(sheetName) {
                const data = this.sheetsData[sheetName];

                if (!data || data.length === 0) {
                    document.getElementById('main-table-firefox-container-inner').innerHTML = '<p>No hay datos en esta hoja.</p>';
                    return;
                }

                const headers = data[0];
                const rows = data.slice(1);

                // GENERAR SOLO LA NUEVA TABLA
                let tableHTMLFirefox = '<table class="main-table-firefox"><thead><tr>';
                headers.forEach((header, headerIndex) => {
                    if (headerIndex === 0) { // Columna de Fecha
                        tableHTMLFirefox += `<th class="sortable-header" onclick="window.pcBuildsViewer.sortTable(0)">
                            <div class="sortable-header-content">
                                <span class="header-text">${header}</span>
                                <div class="sort-indicator">
                                    <span class="sort-arrow sort-arrow-up">‚ñ≤</span>
                                    <span class="sort-arrow sort-arrow-down">‚ñº</span>
                                </div>
                            </div>
                        </th>`;
                    } else if (headerIndex === 2) { // Tercera columna - Precio en ‚Ç¨
                        tableHTMLFirefox += `<th class="sortable-header" onclick="window.pcBuildsViewer.sortTable(2)">
                            <div class="sortable-header-content">
                                <span class="header-text">Precio ‚Ç¨*</span>
                                <div class="sort-indicator">
                                    <span class="sort-arrow sort-arrow-up">‚ñ≤</span>
                                    <span class="sort-arrow sort-arrow-down">‚ñº</span>
                                </div>
                            </div>
                        </th>`;
                    } else {
                        tableHTMLFirefox += `<th>${header}</th>`;
                    }
                });
                
                tableHTMLFirefox += '</tr></thead><tbody>';

                rows.forEach((row, index) => {
                    tableHTMLFirefox += '<tr class="data-row main-table-row">';
                    headers.forEach((header, cellIndex) => {
                        const cellValue = row[cellIndex] || '';
                        tableHTMLFirefox += `<td class="data-cell">${cellValue}</td>`;
                    });
                    
                    tableHTMLFirefox += '</tr>';
                });

                tableHTMLFirefox += '</tbody></table>';
                document.getElementById('main-table-firefox-container-inner').innerHTML = tableHTMLFirefox;
                
                // MOSTRAR el contenedor de la tabla principal
                document.getElementById('main-table-firefox-container').classList.remove('hidden');
                document.getElementById('stats-info').classList.remove('hidden');
                
                // A√±adir botones de eliminar flotantes en cada fila
                this.addFloatingDeleteButtons();
                
                // A√±adir el mensaje explicativo FUERA del contenedor de la tabla (solo una vez)
                if (!this.priceMessageCreated) {
                    const tableWrapper = document.querySelector('.table-wrapper');
                    if (tableWrapper) {
                        // Verificar si ya existe un mensaje
                        const existingMessage = document.getElementById('price-explanation-message');
                        if (!existingMessage) {
                            const messageElement = document.createElement('p');
                            messageElement.className = 'price-explanation';
                            messageElement.textContent = '* El precio es de todos los componentes.';
                            messageElement.id = 'price-explanation-message';
                            tableWrapper.parentNode.insertBefore(messageElement, tableWrapper.nextSibling);
                            this.priceMessageCreated = true;
                        }
                    }
                }
                
                // Actualizar estado inicial de los botones de scroll
                setTimeout(() => {
                    if (typeof updateScrollButtons === 'function') {
                        updateScrollButtons();
                    }
                }, 100);
            
            // A√±adir botones de eliminar flotantes
            this.addFloatingDeleteButtons();
                
                // Establecer estado inicial de ordenamiento solo si no hay estado previo
                if (!this.sortStates || Object.keys(this.sortStates).length === 0) {
                    this.setSortState(0, 'desc'); // Fecha decreciente por defecto
                    this.setSortState(2, null); // Precio sin ordenamiento inicial
                    this.updateSortIndicators(0, 'desc');
                    this.updateSortIndicators(2, null);
                    

                } else {
                    // Restaurar el estado de ordenamiento existente
                    Object.entries(this.sortStates).forEach(([columnIndex, direction]) => {
                        this.updateSortIndicators(parseInt(columnIndex), direction);
                    });
                }
                

            }
            
                        // A√±adir botones de eliminar flotantes en cada fila
            addFloatingDeleteButtons() {
                // Solo mostrar botones si el usuario est√° autenticado
                if (!this.isAuthenticated) return;
                
                const rows = document.querySelectorAll('.data-row');
                

                
                rows.forEach((row, domIndex) => {
                    // Obtener la primera celda (columna Fecha)
                    const cells = row.querySelectorAll('td');
                    const firstCell = cells[0]; // Primera celda (Fecha)
                    
                    if (firstCell) {
                        // Verificar si ya existe un bot√≥n de eliminar
                        const existingBtn = firstCell.querySelector('.delete-row-btn-floating');
                        if (existingBtn) {
                            existingBtn.remove();
                        }
                        
                        // Hacer que la celda de Fecha sea relativa para posicionar el bot√≥n
                        firstCell.style.position = 'relative';
                        
                        // Crear bot√≥n de eliminar
                        const deleteBtn = document.createElement('button');
                        deleteBtn.className = 'delete-row-btn-floating';
                        deleteBtn.innerHTML = 'üóëÔ∏è';
                        deleteBtn.title = 'üóëÔ∏è Eliminar montaje';
                        deleteBtn.setAttribute('aria-label', 'Eliminar montaje');
                        deleteBtn.style.cursor = 'pointer'; // Solo el bot√≥n tiene cursor pointer
                        
                        // Obtener los datos de la fila para eliminaci√≥n
                        const fechaCell = firstCell.textContent.trim();
                        const tituloCell = cells[1]?.textContent.trim() || '';
                        const precioCell = cells[2]?.textContent.trim() || '';
                        const procesadorCell = cells[3]?.textContent.trim() || '';
                        const graficaCell = cells[4]?.textContent.trim() || '';
                        const torreCell = cells[5]?.textContent.trim() || '';
                        
                        // Crear objeto con los datos de la fila
                        const rowData = [fechaCell, tituloCell, precioCell, procesadorCell, graficaCell, torreCell];
                        
                        deleteBtn.onclick = () => this.deleteRowByData(rowData);
                        
                        // Posicionar el bot√≥n en la esquina izquierda de la celda
                        deleteBtn.style.left = '5px';
                        deleteBtn.style.right = 'auto';
                        
                        // A√±adir el bot√≥n a la celda de Fecha
                        firstCell.appendChild(deleteBtn);
                        
                        // HOVER COMPATIBLE CON TODOS LOS NAVEGADORES
                        row.addEventListener('mouseenter', () => {
                            // Hover en la fila - solo cambiar color de fondo
                            row.style.backgroundColor = '#e3f2fd';
                            
                            // Mostrar bot√≥n de eliminar
                            deleteBtn.style.opacity = '1';
                            deleteBtn.style.visibility = 'visible';
                        });
                        
                        row.addEventListener('mouseleave', () => {
                            // Quitar hover de la fila - solo cambiar color de fondo
                            row.style.backgroundColor = '';
                            
                            // Mantener bot√≥n visible pero con opacidad muy reducida
                            deleteBtn.style.opacity = '0.2';
                            deleteBtn.style.visibility = 'visible';
                        });
                    }
                });
            }

            // M√©todo para ordenar la tabla por columna
            sortTable(columnIndex) {
                const data = this.sheetsData['Datos'];
                if (!data || data.length < 2) return;

                const headers = data[0];
                const rows = data.slice(1);
                
                // Resetear el estado de ordenamiento de otras columnas
                Object.keys(this.sortStates || {}).forEach(colIndex => {
                    if (parseInt(colIndex) !== columnIndex) {
                        this.resetSortState(parseInt(colIndex));
                    }
                });
                
                // Obtener el estado actual de ordenamiento para esta columna
                const currentSortState = this.getSortState(columnIndex);
                const newSortDirection = currentSortState === 'asc' ? 'desc' : 'asc';
                
                // Ordenar las filas
                const sortedRows = this.sortRows(rows, columnIndex, newSortDirection);
                
                // Actualizar el estado de ordenamiento
                this.setSortState(columnIndex, newSortDirection);
                
                // Actualizar los indicadores visuales
                this.updateSortIndicators(columnIndex, newSortDirection);
                
                // Recrear la tabla con los datos ordenados
                const newData = [headers, ...sortedRows];
                this.sheetsData['Datos'] = newData;
                this.displaySheetData('Datos');
                
                // Restaurar el estado de ordenamiento despu√©s de recrear la tabla
                this.updateSortIndicators(columnIndex, newSortDirection);
                
                // Mostrar mensaje de confirmaci√≥n
                const columnName = columnIndex === 0 ? 'Fecha' : 'Precio';
                const direction = newSortDirection === 'asc' ? 'ascendente' : 'descendente';
                this.showSortConfirmation(columnName, direction);
            }

            // Obtener el estado actual de ordenamiento para una columna
            getSortState(columnIndex) {
                if (!this.sortStates) this.sortStates = {};
                return this.sortStates[columnIndex] || null;
            }

            // Establecer el estado de ordenamiento para una columna
            setSortState(columnIndex, direction) {
                if (!this.sortStates) this.sortStates = {};
                this.sortStates[columnIndex] = direction;
            }

            // Resetear el estado de ordenamiento de una columna espec√≠fica
            resetSortState(columnIndex) {
                if (!this.sortStates) this.sortStates = {};
                this.sortStates[columnIndex] = null;
                this.updateSortIndicators(columnIndex, null);
            }



            // Ordenar las filas seg√∫n la columna y direcci√≥n
            sortRows(rows, columnIndex, direction) {
                return [...rows].sort((a, b) => {
                    let valueA = a[columnIndex];
                    let valueB = b[columnIndex];

                    if (columnIndex === 0) { // Columna de Fecha
                        // Convertir fechas a objetos Date para comparaci√≥n
                        valueA = this.parseDate(valueA);
                        valueB = this.parseDate(valueB);
                        
                        if (direction === 'asc') {
                            return valueA - valueB;
                        } else {
                            return valueB - valueA;
                        }
                    } else if (columnIndex === 2) { // Columna de Precio
                        // Convertir precios a n√∫meros para comparaci√≥n
                        valueA = this.parsePrice(valueA);
                        valueB = this.parsePrice(valueB);
                        
                        if (direction === 'asc') {
                            return valueA - valueB;
                        } else {
                            return valueB - valueA;
                        }
                    }
                    
                    return 0;
                });
            }

            // Parsear fecha en diferentes formatos
            parseDate(dateStr) {
                if (!dateStr || !dateStr.trim()) return new Date(0);
                
                // Intentar formato est√°ndar
                let date = new Date(dateStr);
                if (!isNaN(date.getTime())) return date;
                
                // Intentar formato DD-MM-YYYY
                const parts = dateStr.split('-');
                if (parts.length === 3) {
                    date = new Date(parts[2], parts[1] - 1, parts[0]);
                    if (!isNaN(date.getTime())) return date;
                }
                
                // Si no se puede parsear, retornar fecha m√≠nima
                return new Date(0);
            }

            // Parsear precio a n√∫mero
            parsePrice(priceStr) {
                if (!priceStr || !priceStr.trim()) return 0;
                
                // Remover s√≠mbolos de moneda y espacios
                const cleanPrice = priceStr.toString().replace(/[‚Ç¨\s,]/g, '');
                const price = parseFloat(cleanPrice);
                
                return isNaN(price) ? 0 : price;
            }

            // Actualizar indicadores visuales de ordenamiento
            updateSortIndicators(columnIndex, direction) {
                // Resetear todos los indicadores
                const allHeaders = document.querySelectorAll('.sortable-header');
                
                allHeaders.forEach((header, index) => {
                    const upArrow = header.querySelector('.sort-arrow-up');
                    const downArrow = header.querySelector('.sort-arrow-down');
                    
                    if (upArrow && downArrow) {
                        upArrow.classList.remove('active');
                        downArrow.classList.remove('active');
                    }
                });
                
                // Activar el indicador correcto para la columna actual
                let headerIndex = columnIndex;
                if (columnIndex === 2) headerIndex = 1; // La columna 2 (precio) es el segundo header sortable
                
                const currentHeader = document.querySelectorAll('.sortable-header')[headerIndex];
                
                if (currentHeader && direction !== null) {
                    const upArrow = currentHeader.querySelector('.sort-arrow-up');
                    const downArrow = currentHeader.querySelector('.sort-arrow-down');
                    
                    if (direction === 'asc' && upArrow) {
                        upArrow.classList.add('active');
                    } else if (direction === 'desc' && downArrow) {
                        downArrow.classList.add('active');
                    }
                }
            }

            // Mostrar confirmaci√≥n de ordenamiento
            showSortConfirmation(columnName, direction) {
                const message = `üìä Tabla ordenada por ${columnName} en orden ${direction}`;
                
                // Crear o actualizar el mensaje de confirmaci√≥n
                let confirmationDiv = document.querySelector('.sort-confirmation');
                if (!confirmationDiv) {
                    confirmationDiv = document.createElement('div');
                    confirmationDiv.className = 'sort-confirmation';
                    document.querySelector('.table-wrapper').parentNode.insertBefore(confirmationDiv, document.querySelector('.table-wrapper').nextSibling);
                }
                
                confirmationDiv.textContent = message;
                confirmationDiv.style.display = 'block';
                
                // Ocultar el mensaje despu√©s de 3 segundos
                setTimeout(() => {
                    confirmationDiv.style.display = 'none';
                }, 3000);
            }

            // Generar estad√≠sticas mensuales
            displayMonthlyStats(data) {
                const monthlyStats = this.calculateMonthlyStats(data);
                const monthlyStatsTable = document.getElementById('monthly-stats-table-final');
                
                if (monthlyStats.length === 0) {
                    monthlyStatsTable.innerHTML = '<p class="no-monthly-data">No hay datos suficientes para estad√≠sticas mensuales.</p>';
                    return;
                }

                let monthlyHTML = `
                    <table class="monthly-stats-table">
                        <thead>
                            <tr>
                                <th>Mes</th>
                                <th>N¬∞ Montajes</th>
                                <th>Promedio ‚Ç¨</th>
                            </tr>
                        </thead>
                        <tbody>
                `;

                monthlyStats.forEach(monthData => {
                    const monthName = this.getMonthName(monthData.month);
                    const avgPrice = Math.round(monthData.avgPrice);
                    
                    monthlyHTML += `
                        <tr>
                            <td>${monthName}</td>
                            <td>${monthData.count}</td>
                            <td>${avgPrice}</td>
                        </tr>
                    `;
                });

                monthlyHTML += '</tbody></table>';
                monthlyStatsTable.innerHTML = monthlyHTML;
            }

            // Calcular estad√≠sticas mensuales
            calculateMonthlyStats(data) {
                const monthlyData = {};
                
                // Procesar cada fila de datos (excluyendo headers)
                data.slice(1).forEach(row => {
                    const dateStr = row[0]; // Primera columna es la fecha
                    const priceStr = row[2]; // Tercera columna es el precio
                    
                    if (!dateStr || !priceStr) return;
                    
                    const date = this.parseDate(dateStr);
                    if (!date || isNaN(date.getTime())) return;
                    
                    const month = date.getMonth();
                    const year = date.getFullYear();
                    const monthKey = `${year}-${month}`;
                    
                    const price = this.parsePrice(priceStr);
                    if (isNaN(price)) return;
                    
                    if (!monthlyData[monthKey]) {
                        monthlyData[monthKey] = {
                            month: month,
                            year: year,
                            count: 0,
                            totalPrice: 0
                        };
                    }
                    
                    monthlyData[monthKey].count++;
                    monthlyData[monthKey].totalPrice += price;
                });
                
                // Calcular promedios
                Object.values(monthlyData).forEach(monthData => {
                    monthData.avgPrice = monthData.totalPrice / monthData.count;
                });
                
                // Ordenar por fecha (de m√°s actual a menos actual)
                return Object.values(monthlyData)
                    .sort((a, b) => {
                        if (a.year !== b.year) return b.year - a.year; // A√±o m√°s reciente primero
                        return b.month - a.month; // Mes m√°s reciente primero
                    });
            }

            // Obtener nombre del mes en espa√±ol
            getMonthName(monthIndex) {
                const months = [
                    'Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio',
                    'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'
                ];
                return months[monthIndex];
            }

            // ===== FUNCIONES DE AUTOMATIZACI√ìN =====

            // Mostrar/ocultar el formulario de automatizaci√≥n
            toggleAutomation() {
                const automationForm = document.getElementById('automation-form');
                if (automationForm.classList.contains('hidden')) {
                    automationForm.classList.remove('hidden');
                    // Scroll suave hacia el formulario
                    automationForm.scrollIntoView({ behavior: 'smooth' });
                } else {
                    automationForm.classList.add('hidden');
                }
            }

            // Extraer informaci√≥n del t√≠tulo de Twitch
            extractTwitchInfo() {
                const titleInput = document.getElementById('twitch-title-input');
                const title = titleInput.value.trim();
                
                if (!title) {
                    alert('Por favor, introduce un t√≠tulo de Twitch');
                    return;
                }

                const extractedInfo = this.parseTwitchTitle(title);
                this.displayExtractedInfo(extractedInfo);
            }

            // Analizar el t√≠tulo de Twitch y extraer informaci√≥n
            parseTwitchTitle(title) {
                const result = {
                    price: '',
                    processor: '',
                    graphics: '',
                    case: ''
                };

                // Extraer precio (formato: n√∫mero + ‚Ç¨)
                const priceMatch = title.match(/(\d+(?:\.\d+)?)\s*‚Ç¨/);
                if (priceMatch) {
                    result.price = priceMatch[1]; // Solo el n√∫mero, sin el ‚Ç¨
                }

                // Extraer procesador usando datos reales de la tabla de an√°lisis
                result.processor = this.findBestMatch(title, 'processor');

                // Extraer tarjeta gr√°fica usando datos reales de la tabla de an√°lisis
                result.graphics = this.findBestMatch(title, 'graphics');

                // Extraer torre usando datos reales de la tabla de an√°lisis
                result.case = this.findBestMatch(title, 'case');

                return result;
            }

            // Encontrar la mejor coincidencia basada en datos reales
            findBestMatch(title, componentType) {
                if (!this.sheetsData['Datos'] || this.sheetsData['Datos'].length < 2) {
                    return this.fallbackPatternMatching(title, componentType);
                }

                // Para gr√°ficas, SIEMPRE usar fallback si hay sufijos TI/SUPER/XT en el t√≠tulo
                if (componentType === 'graphics') {
                    const hasSuffix = /(rtx|gtx|rx)\s*\d{3,4}\s*(ti|super|xt)/i.test(title);
                    if (hasSuffix) {
                        return this.fallbackPatternMatching(title, componentType);
                    }
                }

                // Obtener componentes √∫nicos de la tabla de an√°lisis
                const components = this.getUniqueComponents(componentType);
                if (components.length === 0) {
                    return this.fallbackPatternMatching(title, componentType);
                }

                // Buscar la mejor coincidencia
                let bestMatch = '';
                let bestScore = 0;

                for (const component of components) {
                    const score = this.calculateMatchScore(title, component);
                    if (score > bestScore) {
                        bestScore = score;
                        bestMatch = component;
                    }
                }

                // Solo devolver si la coincidencia es suficientemente buena
                return bestScore >= 0.6 ? bestMatch : this.fallbackPatternMatching(title, componentType);
            }

            // Obtener componentes √∫nicos de la tabla de an√°lisis
            getUniqueComponents(componentType) {
                const columnIndex = {
                    'processor': 3,
                    'graphics': 4,
                    'case': 5
                }[componentType];

                if (columnIndex === undefined) return [];

                const components = new Set();
                for (let i = 1; i < this.sheetsData['Datos'].length; i++) {
                    const component = this.sheetsData['Datos'][i][columnIndex];
                    if (component && component.trim()) {
                        components.add(component.trim());
                    }
                }

                return Array.from(components);
            }

            // Calcular puntuaci√≥n de coincidencia
            calculateMatchScore(title, component) {
                const titleLower = title.toLowerCase();
                const componentLower = component.toLowerCase();
                
                // Buscar coincidencias exactas primero
                if (titleLower.includes(componentLower)) {
                    return 1.0;
                }

                // Buscar coincidencias parciales
                const componentWords = componentLower.split(/\s+/);
                let score = 0;
                let foundWords = 0;

                for (const word of componentWords) {
                    if (word.length > 2 && titleLower.includes(word)) {
                        score += 0.3;
                        foundWords++;
                    }
                }

                // Bonus por encontrar m√∫ltiples palabras
                if (foundWords > 1) {
                    score += 0.2;
                }

                return score;
            }

            // Fallback a patrones predefinidos si no hay datos de an√°lisis
            fallbackPatternMatching(title, componentType) {
                if (componentType === 'processor') {
                    return this.fallbackProcessorMatching(title);
                } else if (componentType === 'graphics') {
                    return this.fallbackGraphicsMatching(title);
                } else if (componentType === 'case') {
                    return this.fallbackCaseMatching(title);
                }
                return '';
            }

            // Fallback para procesadores
            fallbackProcessorMatching(title) {
                const processorPatterns = [
                    /(\d{3,4}[Xx]3[Dd])/i,           // 9800X3D, 9950X3D
                    /(\d{3,4}[Xx])/i,                 // 9600X, 9700X
                    /(ryzen\s+\d{3,4}[Xx]3[Dd])/i,   // Ryzen 9800X3D
                    /(ryzen\s+\d{3,4}[Xx])/i,        // Ryzen 9600X
                    /(intel\s+\d{3,4}[Kk])/i,        // Intel 14900K
                    /(\d{3,4}[Kk])/i,                 // 14900K, 14700K
                    /(i\d{1,2}-\d{3,4}[Kk])/i        // i9-14900K, i7-14700K
                ];

                for (const pattern of processorPatterns) {
                    const match = title.match(pattern);
                    if (match) {
                        let processor = match[1];
                        if (/^\d{3,4}[Xx]3[Dd]$/i.test(processor)) {
                            processor = 'AMD RYZEN 9 ' + processor.toUpperCase();
                        } else if (/^\d{3,4}[Xx]$/i.test(processor)) {
                            processor = 'AMD RYZEN 7 ' + processor.toUpperCase();
                        } else if (/^\d{3,4}[Kk]$/i.test(processor)) {
                            processor = 'INTEL ' + processor.toUpperCase();
                        } else if (/^i\d{1,2}-\d{3,4}[Kk]$/i.test(processor)) {
                            processor = 'INTEL ' + processor.toUpperCase();
                        }
                        return processor;
                    }
                }
                return '';
            }

            // Fallback para gr√°ficas
            fallbackGraphicsMatching(title) {
                console.log('=== DEBUG GR√ÅFICAS ===');
                console.log('T√≠tulo a analizar:', title);
                
                // M√©todo 1: Buscar RTX con sufijo TI/SUPER
                const rtxWithSuffix = title.match(/(rtx\s*\d{3,4})\s*(ti|super)/i);
                if (rtxWithSuffix) {
                    console.log('RTX con sufijo encontrado:', rtxWithSuffix);
                    const model = rtxWithSuffix[1];  // RTX 5070
                    const suffix = rtxWithSuffix[2].toUpperCase();  // TI
                    const number = model.match(/\d{3,4}/)[0];
                    const graphics = 'NVIDIA RTX ' + number + ' ' + suffix;
                    console.log('Gr√°fica construida:', graphics);
                    return graphics;
                }
                
                // M√©todo 2: Buscar GTX con sufijo TI/SUPER
                const gtxWithSuffix = title.match(/(gtx\s*\d{3,4})\s*(ti|super)/i);
                if (gtxWithSuffix) {
                    console.log('GTX con sufijo encontrado:', gtxWithSuffix);
                    const model = gtxWithSuffix[1];
                    const suffix = gtxWithSuffix[2].toUpperCase();
                    const number = model.match(/\d{3,4}/)[0];
                    const graphics = 'NVIDIA GTX ' + number + ' ' + suffix;
                    console.log('Gr√°fica construida:', graphics);
                    return graphics;
                }
                
                // M√©todo 3: Buscar RX con sufijo XT
                const rxWithSuffix = title.match(/(rx\s*\d{3,4})\s*(xt)/i);
                if (rxWithSuffix) {
                    console.log('RX con sufijo encontrado:', rxWithSuffix);
                    const model = rxWithSuffix[1];
                    const suffix = rxWithSuffix[2].toUpperCase();
                    const number = model.match(/\d{3,4}/)[0];
                    const graphics = 'AMD RX ' + number + ' ' + suffix;
                    console.log('Gr√°fica construida:', graphics);
                    return graphics;
                }
                
                // M√©todo 4: Buscar RTX b√°sico
                const rtxBasic = title.match(/(rtx\s*\d{3,4})/i);
                if (rtxBasic) {
                    console.log('RTX b√°sico encontrado:', rtxBasic);
                    const model = rtxBasic[1];
                    const number = model.match(/\d{3,4}/)[0];
                    const graphics = 'NVIDIA RTX ' + number;
                    console.log('Gr√°fica b√°sica construida:', graphics);
                    return graphics;
                }
                
                // M√©todo 5: Buscar GTX b√°sico
                const gtxBasic = title.match(/(gtx\s*\d{3,4})/i);
                if (gtxBasic) {
                    console.log('GTX b√°sico encontrado:', gtxBasic);
                    const model = gtxBasic[1];
                    const number = model.match(/\d{3,4}/)[0];
                    const graphics = 'NVIDIA GTX ' + number;
                    console.log('Gr√°fica b√°sica construida:', graphics);
                    return graphics;
                }
                
                // M√©todo 6: Buscar RX b√°sico
                const rxBasic = title.match(/(rx\s*\d{3,4})/i);
                if (rxBasic) {
                    console.log('RX b√°sico encontrado:', rxBasic);
                    const model = rxBasic[1];
                    const number = model.match(/\d{3,4}/)[0];
                    const graphics = 'AMD RX ' + number;
                    console.log('Gr√°fica b√°sica construida:', graphics);
                    return graphics;
                }
                
                console.log('No se encontr√≥ coincidencia para gr√°fica');
                return '';
            }

            // Funci√≥n de debug para probar la extracci√≥n
            debugTest() {
                const testTitle = "Montaje PC 3100‚Ç¨ - 9800X3D & RTX 5070 Ti & NZXT H9 Flow";
                console.log('=== DEBUG TEST ===');
                
                // Probar extracci√≥n de precio
                const priceMatch = testTitle.match(/(\d+(?:\.\d+)?)\s*‚Ç¨/);
                
                // Probar extracci√≥n de gr√°fica
                const result = this.parseTwitchTitle(testTitle);
                
                // Probar funci√≥n de fallback espec√≠ficamente
                const graphicsFallback = this.fallbackGraphicsMatching(testTitle);
                
                // Mostrar en la interfaz
                alert(`Debug completado. Revisa la consola del navegador (F12) para ver los detalles.\n\nResultado:\nPrecio: ${result.price}\nGr√°fica: ${result.graphics}`);
            }

            // Migrar todos los datos de Google Sheets a localStorage
            migrateAllDataToLocal() {
                if (!this.sheetsData['Datos'] || this.sheetsData['Datos'].length < 2) {
                    alert('‚ùå No hay datos de Google Sheets para migrar');
                    return;
                }

                try {
                    // Obtener entradas existentes del localStorage
                    const existingEntries = JSON.parse(localStorage.getItem('gabyLocalEntries') || '[]');
                    
                    // Obtener TODOS los datos de Google Sheets (excluyendo headers)
                    const googleSheetsData = this.sheetsData['Datos'].slice(1);
                    
                    // MIGRAR TODAS LAS ENTRADAS (sin filtrar por fecha)
                    const allDataToMigrate = googleSheetsData;
                    
                    if (allDataToMigrate.length === 0) {
                        alert('‚úÖ No hay datos para migrar');
                        return;
                    }
                    
                    // Combinar entradas existentes con TODOS los datos de Google Sheets
                    const allEntries = [...existingEntries, ...allDataToMigrate];
                    
                    // Guardar en localStorage
                    localStorage.setItem('gabyLocalEntries', JSON.stringify(allEntries));
                    
                    // Actualizar contador de entradas locales
                    this.updateLocalEntriesCount();
                    
                    // Mostrar mensaje de √©xito
                    const message = `‚úÖ Migraci√≥n completada:\n\n` +
                                  `üìä Datos migrados: ${allDataToMigrate.length} entradas\n` +
                                  `üìÖ Incluye: TODAS las entradas hist√≥ricas\n` +
                                  `üíæ Total en local: ${allEntries.length} entradas\n\n` +
                                  `üîÑ Recarga la p√°gina para ver todos los datos`;
                    
                    alert(message);
                    
                } catch (error) {
                    alert('‚ùå Error durante la migraci√≥n: ' + error.message);
                }
            }

            // Fallback para torres
            fallbackCaseMatching(title) {
                const casePatterns = [
                    /(?:[&|]\s*)([A-Za-z]+\s+\d+\s*[A-Za-z]*)/i,
                    /(?:-\s*)([A-Za-z]+\s+\d+\s*[A-Za-z]*)/i,
                    /(?:[&|]\s*)([A-Za-z]+\s*[A-Za-z]*\s*\d+)/i,
                    /(?:-\s*)([A-Za-z]+\s*[A-Za-z]*\s*\d+)/i
                ];

                for (const pattern of casePatterns) {
                    const match = title.match(pattern);
                    if (match) {
                        const caseCandidate = match[1].trim();
                        if (!caseCandidate.match(/^(?:ryzen|intel|amd|nvidia|rtx|gtx|rx|i\d{1,2}-\d{3,4}|x3d)/i)) {
                            return caseCandidate.toUpperCase();
                        }
                    }
                }

                const parts = title.split(/[&|-]/);
                if (parts.length > 0) {
                    const lastPart = parts[parts.length - 1].trim();
                                         if (lastPart && !lastPart.match(/^(?:ryzen|intel|amd|nvidia|rtx|gtx|rx|i\d{1,2}-\d{3,4}|x3d)/i)) {
                         return lastPart.toUpperCase();
                     }
                }
                return '';
            }

            // Mostrar la informaci√≥n extra√≠da
            displayExtractedInfo(info) {
                // Establecer fecha actual por defecto
                const today = new Date();
                const currentDate = today.toISOString().split('T')[0]; // Formato YYYY-MM-DD
                document.getElementById('extracted-date').value = currentDate;
                
                document.getElementById('extracted-price').value = info.price || '';
                document.getElementById('extracted-processor').value = (info.processor || '').toUpperCase();
                document.getElementById('extracted-graphics').value = (info.graphics || '').toUpperCase();
                document.getElementById('extracted-case').value = (info.case || '').toUpperCase();
                
                document.getElementById('extraction-results').classList.remove('hidden');
                
                // Scroll suave a los resultados
                document.getElementById('extraction-results').scrollIntoView({ behavior: 'smooth' });
            }



            // Limpiar el formulario
            clearAutomationForm() {
                document.getElementById('twitch-title-input').value = '';
                document.getElementById('extraction-results').classList.add('hidden');
                
                // Limpiar los valores mostrados
                document.getElementById('extracted-price').value = '';
                document.getElementById('extracted-processor').value = '';
                document.getElementById('extracted-graphics').value = '';
                document.getElementById('extracted-case').value = '';
                document.getElementById('extracted-date').value = '';
            }

            // Copiar todos los resultados al portapapeles
            async copyAllResults() {
                const price = document.getElementById('extracted-price').textContent;
                const processor = document.getElementById('extracted-processor').textContent;
                const graphics = document.getElementById('extracted-graphics').textContent;
                const case_ = document.getElementById('extracted-case').textContent;
                
                const textToCopy = `Precio: ${price}\nProcesador: ${processor}\nTarjeta Gr√°fica: ${graphics}\nTorre: ${case_}`;
                
                try {
                    await navigator.clipboard.writeText(textToCopy);
                    this.showCopySuccess('¬°Informaci√≥n copiada al portapapeles!');
                } catch (err) {
                    // Fallback para navegadores que no soportan clipboard API
                    const textArea = document.createElement('textarea');
                    textArea.value = textToCopy;
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                    this.showCopySuccess('¬°Informaci√≥n copiada al portapapeles!');
                }
            }

            // Mostrar opciones de copia individual
            showIndividualCopyOptions() {
                const options = [
                    { id: 'extracted-price', label: 'Precio' },
                    { id: 'extracted-processor', label: 'Procesador' },
                    { id: 'extracted-graphics', label: 'Tarjeta Gr√°fica' },
                    { id: 'extracted-case', label: 'Torre' }
                ];

                let optionsHTML = '<div class="individual-copy-options">';
                options.forEach(option => {
                    const value = document.getElementById(option.id).textContent;
                    if (value && value !== 'No encontrado') {
                        optionsHTML += `
                            <button onclick="window.pcBuildsViewer.copyIndividualValue('${option.id}')" class="copy-individual-option">
                                üìã Copiar ${option.label}: ${value}
                            </button>
                        `;
                    }
                });
                optionsHTML += '</div>';

                // Reemplazar el bot√≥n con las opciones
                const copyIndividualBtn = document.getElementById('copy-individual-btn');
                copyIndividualBtn.innerHTML = optionsHTML;
                
                // Restaurar el bot√≥n despu√©s de 10 segundos
                setTimeout(() => {
                    copyIndividualBtn.innerHTML = 'üìù Copiar Individual';
                }, 10000);
            }

            // Copiar un valor individual
            async copyIndividualValue(elementId) {
                const element = document.getElementById(elementId);
                const value = element.textContent;
                
                try {
                    await navigator.clipboard.writeText(value);
                    this.showCopySuccess(`¬°${value} copiado al portapapeles!`);
                } catch (err) {
                    // Fallback para navegadores que no soportan clipboard API
                    const textArea = document.createElement('textarea');
                    textArea.value = value;
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                    this.showCopySuccess(`¬°${value} copiado al portapapeles!`);
                }
            }

            // Mostrar mensaje de √©xito al copiar
            showCopySuccess(message, duration = 3000, type = 'success') {
                // Crear mensaje temporal
                const successMsg = document.createElement('div');
                successMsg.className = 'copy-success-message';
                successMsg.textContent = message;
                
                // Estilos base
                let background, color, shadowColor;
                
                if (type === 'error' || type === 'delete') {
                    background = '#FF6B6B';
                    color = 'white';
                    shadowColor = 'rgba(255, 107, 107, 0.3)';
                } else {
                    background = '#00E676';
                    color = 'black';
                    shadowColor = 'rgba(0, 230, 118, 0.3)';
                }
                
                successMsg.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: ${background};
                    color: ${color};
                    padding: 15px 20px;
                    border-radius: 8px;
                    box-shadow: 0 4px 15px ${shadowColor};
                    z-index: 1000;
                    font-weight: 600;
                    animation: slideInRight 0.3s ease-out;
                    white-space: pre-line;
                `;
                
                document.body.appendChild(successMsg);
                
                // Eliminar despu√©s del tiempo especificado (por defecto 3 segundos)
                setTimeout(() => {
                    if (successMsg.parentNode) {
                        successMsg.parentNode.removeChild(successMsg);
                    }
                }, duration);
            }

            // A√±adir informaci√≥n extra√≠da a la tabla principal
            async addToMainTable() {
                // Obtener la fecha del campo editable PRIMERO
                const currentDate = document.getElementById('extracted-date').value;
                
                // Obtener los valores de los campos editables
                const price = document.getElementById('extracted-price').value;
                const processor = document.getElementById('extracted-processor').value;
                const graphics = document.getElementById('extracted-graphics').value;
                const case_ = document.getElementById('extracted-case').value;
                
                // Verificar que todos los campos tengan informaci√≥n
                if (!currentDate || !price || !processor || !graphics || !case_) {
                    alert('‚ùå Error: No se puede a√±adir a la tabla. Aseg√∫rate de que todos los campos tengan informaci√≥n v√°lida.');
                    return;
                }
                
                // Obtener el t√≠tulo original del input
                const titleInput = document.getElementById('twitch-title-input');
                const originalTitle = titleInput.value.trim();
                
                try {
    
                    
                    // Enviar al backend
                                            const response = await fetch(this.getApiUrl('/api/add-montage'), {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            fecha: currentDate,
                            titulo: originalTitle,
                            precio: price,
                            procesador: processor,
                            grafica: graphics,
                            torre: case_
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`Error del servidor: ${response.status}`);
                    }

                    const result = await response.json();
                    
                    if (!result.success) {
                        throw new Error(result.error || 'Error al a√±adir montaje');
                    }

    
                    
                    // Recargar datos desde el backend con timeout de seguridad
                    try {
                        const loadPromise = this.loadDataFromBackend();
                        const timeoutPromise = new Promise((_, reject) => 
                            setTimeout(() => reject(new Error('Timeout al recargar datos')), 10000)
                        );
                        
                        await Promise.race([loadPromise, timeoutPromise]);
                    } catch (loadError) {
                        console.error('‚ùå Error al recargar datos:', loadError);
                        // Ocultar spinner si falla la recarga
                        this.hideLoading();
                        // Continuar con el proceso aunque falle la recarga
                    }
                    
                    // Limpiar el formulario
                    this.clearAutomationForm();
                    
                    // Ocultar el formulario de automatizaci√≥n
                    document.getElementById('automation-form').classList.add('hidden');
                    
                    // Asegurar que el spinner est√© oculto
                    this.hideLoading();
                    
                    // Mostrar mensaje de √©xito con fecha
                    this.showCopySuccess(`‚úÖ ¬°Nuevo montaje a√±adido! üìÖ Fecha: ${currentDate}`, 8000);
                    
                    // Hacer scroll a la tabla para mostrar la nueva entrada
                    setTimeout(() => {
                        const tableContainer = document.getElementById('main-table-firefox-container');
                        if (tableContainer) {
                            tableContainer.scrollIntoView({ behavior: 'smooth' });
                        }
                    }, 500);
                    
                } catch (error) {
                    console.error('‚ùå Error al a√±adir montaje:', error);
                    // Asegurar que el spinner est√© oculto en caso de error
                    this.hideLoading();
                    alert('‚ùå Error al a√±adir montaje: ' + error.message);
                }
            }

            // Guardar entrada en localStorage
            saveLocalEntry(newRow) {
                try {
                    // Obtener entradas existentes del localStorage
                    const existingEntries = JSON.parse(localStorage.getItem('gabyLocalEntries') || '[]');
                    
                    // A√±adir la nueva entrada al inicio
                    existingEntries.unshift(newRow);
                    
                    // Guardar en localStorage
                    localStorage.setItem('gabyLocalEntries', JSON.stringify(existingEntries));
                    
    
                } catch (error) {
                    console.error('Error al guardar en localStorage:', error);
                }
            }

            // Cargar entradas locales y combinarlas con los datos de Google Sheets
            loadLocalEntries() {
                try {
                    const localEntries = JSON.parse(localStorage.getItem('gabyLocalEntries') || '[]');
                    
                    if (localEntries.length > 0 && this.sheetsData['Datos'] && this.sheetsData['Datos'].length > 0) {
                        // Obtener headers
                        const headers = this.sheetsData['Datos'][0];
                        
                        // Combinar entradas locales con datos existentes
                        const combinedData = [headers, ...localEntries, ...this.sheetsData['Datos'].slice(1)];
                        
                        // Actualizar los datos
                        this.sheetsData['Datos'] = combinedData;
                        
                        // Actualizar la tabla
                        this.displaySheetData('Datos');
                        this.displayStats();
                        this.generateAnalysis(combinedData);
                        
                        // Actualizar el contador de entradas locales
                        this.updateLocalEntriesCount();
                    } else {
        

                        
                        // Si no hay entradas locales, mostrar solo headers
                        if (this.sheetsData['Datos'] && this.sheetsData['Datos'].length > 0) {
                            this.displaySheetData('Datos');
                            this.displayStats();
                            this.generateAnalysis(this.sheetsData['Datos']);
                        }
                    }
                } catch (error) {
                    console.error('‚ùå Error al cargar entradas locales:', error);
                }
            }

            // Limpiar todas las entradas locales
            clearLocalEntries() {
                if (confirm('¬øEst√°s seguro de que quieres eliminar TODAS las entradas locales? Esta acci√≥n no se puede deshacer.')) {
                    localStorage.removeItem('gabyLocalEntries');
                    this.showCopySuccess('üóëÔ∏è Entradas locales eliminadas');
                    
                    // Actualizar el contador
                    this.updateLocalEntriesCount();
                    
                    // En modo offline, solo mostrar headers
                    if (this.sheetsData['Datos'] && this.sheetsData['Datos'].length > 0) {
                        this.sheetsData['Datos'] = [this.sheetsData['Datos'][0]]; // Solo headers
                        this.displaySheetData('Datos');
                        this.displayStats();
                        this.generateAnalysis(this.sheetsData['Datos']);
                    }
                }
            }

            // Eliminar todas las entradas locales de la tabla
            deleteAllLocalEntries() {
                if (!this.sheetsData['Datos'] || this.sheetsData['Datos'].length < 2) {
                    alert('‚ùå No hay datos para eliminar');
                    return;
                }

                const localEntries = JSON.parse(localStorage.getItem('gabyLocalEntries') || '[]');
                if (localEntries.length === 0) {
                    alert('‚ÑπÔ∏è No hay entradas locales para eliminar');
                    return;
                }

                if (!confirm(`¬øEst√°s seguro de que quieres eliminar TODAS las ${localEntries.length} entradas locales de la tabla?\n\nEsta acci√≥n no se puede deshacer.`)) {
                    return;
                }

                // Eliminar entradas locales de la tabla
                const originalData = this.sheetsData['Datos'].slice(1); // Sin headers
                const filteredData = originalData.filter(row => {
                    return !localEntries.some(localEntry => 
                        localEntry[0] === row[0] && 
                        localEntry[1] === row[1] && 
                        localEntry[2] === row[2]
                    );
                });

                // Reconstruir la tabla sin entradas locales
                this.sheetsData['Datos'] = [this.sheetsData['Datos'][0], ...filteredData];

                // Limpiar localStorage
                localStorage.removeItem('gabyLocalEntries');

                // Actualizar la tabla
                this.displaySheetData('Datos');
                this.displayStats();
                this.generateAnalysis(this.sheetsData['Datos']);
                this.updateLocalEntriesCount();

                // Mostrar mensaje de confirmaci√≥n
                this.showCopySuccess(`üóëÔ∏è Se eliminaron ${localEntries.length} entradas locales de la tabla`);
            }

            // Actualizar el contador de entradas locales
            updateLocalEntriesCount() {
                try {
                    const localEntries = JSON.parse(localStorage.getItem('gabyLocalEntries') || '[]');
                    const countElement = document.getElementById('local-entries-count');
                    if (countElement) {
                        countElement.textContent = localEntries.length;
                    }
                } catch (error) {
                    console.error('Error al actualizar contador:', error);
                }
            }

            // Eliminar una fila de la tabla por datos (INDEPENDIENTE DEL ORDEN)
            async deleteRowByData(rowData) {
                if (!this.sheetsData['Datos'] || this.sheetsData['Datos'].length < 2) {
                    alert('‚ùå No hay datos para eliminar');
                    return;
                }

                // Validar que tengamos los datos de la fila
                if (!rowData || rowData.length < 6) {
                    alert('‚ùå Datos de fila inv√°lidos');
                    return;
                }

                // Confirmar eliminaci√≥n
                const confirmMessage = `¬øEst√°s seguro de que quieres eliminar esta entrada?\n\n` +
                    `Fecha: ${rowData[0]}\n` +
                    `T√≠tulo: ${rowData[1]}\n` +
                    `Precio: ${rowData[2]}‚Ç¨\n` +
                    `Procesador: ${rowData[3]}\n` +
                    `Gr√°fica: ${rowData[4]}\n` +
                    `Torre: ${rowData[5]}`;

                if (!confirm(confirmMessage)) {
                    return;
                }

                try {
                    // Enviar solicitud de eliminaci√≥n al backend por fecha
                    const response = await fetch(this.getApiUrl('/api/delete-montage-by-date'), {
                        method: 'DELETE',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            fecha: rowData[0],
                            titulo: rowData[1]
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`Error del servidor: ${response.status}`);
                    }

                    const result = await response.json();
                    
                    if (!result.success) {
                        throw new Error(result.error || 'Error al eliminar montaje');
                    }
                    
                    // Recargar datos desde el backend
                    await this.loadDataFromBackend();
                    
                    // Mostrar mensaje de confirmaci√≥n con fecha
                    const fechaEliminada = rowData[0];
                    this.showCopySuccess(`Montaje eliminado correctamente\nüìÖ Fecha: ${fechaEliminada}`, 5000, 'delete');
                    
                } catch (error) {
                    console.error('‚ùå Error al eliminar montaje:', error);
                    alert('‚ùå Error al eliminar montaje: ' + error.message);
                }
            }
            
            // Eliminar una fila de la tabla (MANTENER PARA COMPATIBILIDAD)
            async deleteRow(rowIndex) {
                if (!this.sheetsData['Datos'] || this.sheetsData['Datos'].length < 2) {
                    alert('‚ùå No hay datos para eliminar');
                    return;
                }

                // Validar que el √≠ndice sea v√°lido
                if (rowIndex < 1 || rowIndex >= this.sheetsData['Datos'].length) {
                    console.error(`‚ùå √çndice inv√°lido: ${rowIndex}, rango v√°lido: 1-${this.sheetsData['Datos'].length - 1}`);
                    alert('‚ùå √çndice de fila inv√°lido');
                    return;
                }

                // Confirmar eliminaci√≥n
                const rowData = this.sheetsData['Datos'][rowIndex];
                if (!rowData) {
                    alert('‚ùå Fila no encontrada');
                    return;
                }

                const confirmMessage = `¬øEst√°s seguro de que quieres eliminar esta entrada?\n\n` +
                    `Fecha: ${rowData[0]}\n` +
                    `T√≠tulo: ${rowData[1]}\n` +
                    `Precio: ${rowData[2]}‚Ç¨\n` +
                    `Procesador: ${rowData[3]}\n` +
                    `Gr√°fica: ${rowData[4]}\n` +
                    `Torre: ${rowData[5]}`;

                if (!confirm(confirmMessage)) {
                    return;
                }

                try {
                    // El rowIndex ya incluye el offset de los headers, as√≠ que es el √≠ndice correcto
                                        // Usar la nueva funci√≥n que siempre encuentra el √≠ndice correcto
                    const indiceFinal = this.findRealDataIndex(rowData);
                    
                    if (indiceFinal === -1) {
                        throw new Error(`No se pudo encontrar el √≠ndice para la fecha: ${rowData[0]}`);
                    }
                    
                    // Enviar solicitud de eliminaci√≥n al backend
                    const response = await fetch(this.getApiUrl(`/api/delete-montage/${indiceFinal}`), {
                        method: 'DELETE'
                    });

                    if (!response.ok) {
                        throw new Error(`Error del servidor: ${response.status}`);
                    }

                    const result = await response.json();
                    
                    if (!result.success) {
                        throw new Error(result.error || 'Error al eliminar montaje');
                    }
                    
                    // Recargar datos desde el backend
                    await this.loadDataFromBackend();
                    
                    // Mostrar mensaje de confirmaci√≥n con fecha
                    const fechaEliminada = rowData[0];
                    this.showCopySuccess(`Montaje eliminado correctamente\nüìÖ Fecha: ${fechaEliminada}`, 5000, 'delete');
                    
                } catch (error) {
                    console.error('‚ùå Error al eliminar montaje:', error);
                    alert('‚ùå Error al eliminar montaje: ' + error.message);
                }
            }

            // Sistema de autenticaci√≥n
            initAuth() {
                this.isAuthenticated = false;
                this.setupAuthEventListeners();
            }
            
            setupAuthEventListeners() {
                const authButton = document.getElementById('auth-button');
                const authModal = document.getElementById('auth-modal');
                const passwordInput = document.getElementById('password-input');
                const loginBtn = document.getElementById('login-btn');
                const cancelBtn = document.getElementById('cancel-auth-btn');
                const authMessage = document.getElementById('auth-message');
                
                // Mostrar modal al hacer clic en el bot√≥n de autenticaci√≥n
                authButton.addEventListener('click', () => {
                    authModal.style.display = 'block';
                    passwordInput.focus();
                    authMessage.textContent = '';
                    authMessage.className = 'auth-message';
                });
                
                // Cerrar modal al hacer clic en cancelar
                cancelBtn.addEventListener('click', () => {
                    authModal.style.display = 'none';
                    passwordInput.value = '';
                });
                
                // Cerrar modal al hacer clic fuera
                authModal.addEventListener('click', (e) => {
                    if (e.target === authModal) {
                        authModal.style.display = 'none';
                        passwordInput.value = '';
                    }
                });
                
                // Procesar login
                loginBtn.addEventListener('click', () => {
                    this.handleLogin();
                });
                
                // Procesar login con Enter
                passwordInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        this.handleLogin();
                    }
                });
            }
            
            handleLogin() {
                const passwordInput = document.getElementById('password-input');
                const authModal = document.getElementById('auth-modal');
                const authMessage = document.getElementById('auth-message');
                const password = passwordInput.value;
                
                if (password === '*didjujir23*') {
                    this.isAuthenticated = true;
                    authMessage.textContent = '‚úÖ Acceso concedido';
                    authMessage.className = 'auth-message success';
                    
                    // Mostrar funcionalidades avanzadas
                    this.showAdvancedFeatures();
                    
                    // Cerrar modal despu√©s de 1 segundo
                    setTimeout(() => {
                        authModal.style.display = 'none';
                        passwordInput.value = '';
                        authMessage.textContent = '';
                    }, 1000);
                    
                } else {
                    authMessage.textContent = '‚ùå Contrase√±a incorrecta';
                    authMessage.className = 'auth-message error';
                    passwordInput.value = '';
                    passwordInput.focus();
                }
            }
            
            hideAdvancedFeatures() {
                // Ocultar bot√≥n de automatizaci√≥n
                const automationBtn = document.getElementById('toggle-automation-btn');
                if (automationBtn) {
                    automationBtn.classList.add('hidden');
                }
                
                // Ocultar formulario de automatizaci√≥n
                const automationForm = document.getElementById('automation-form');
                if (automationForm) {
                    automationForm.classList.add('hidden');
                }
                
                // Ocultar iconos de exportaci√≥n e importaci√≥n
                const dataActionsCorner = document.getElementById('data-actions-corner');
                if (dataActionsCorner) {
                    dataActionsCorner.classList.add('hidden');
                }
            }
            
            showAdvancedFeatures() {
                // Mostrar bot√≥n de automatizaci√≥n
                const automationBtn = document.getElementById('toggle-automation-btn');
                if (automationBtn) {
                    automationBtn.classList.remove('hidden');
                }
                
                // Mostrar formulario de automatizaci√≥n
                const automationForm = document.getElementById('automation-form');
                if (automationForm) {
                    automationForm.classList.remove('hidden');
                }
                
                // Mostrar iconos de exportaci√≥n e importaci√≥n
                const dataActionsCorner = document.getElementById('data-actions-corner');
                if (dataActionsCorner) {
                    dataActionsCorner.classList.remove('hidden');
                }
                
                // La detecci√≥n de entorno es autom√°tica y transparente
                
                // A√±adir botones de eliminar a la tabla actual
                this.addFloatingDeleteButtons();
            }
            
            // Funci√≥n para exportar datos de la tabla
            exportData() {
                if (!this.isAuthenticated) {
                    alert('‚ùå Debes estar autenticado para exportar datos');
                    return;
                }
                
                try {
                    // Preparar datos para exportar
                    const exportData = {
                        timestamp: new Date().toISOString(),
                        version: '1.0',
                        data: this.sheetsData['Datos'] || [],
                        metadata: {
                            totalRows: this.sheetsData['Datos'] ? this.sheetsData['Datos'].length - 1 : 0,
                            exportDate: new Date().toLocaleDateString('es-ES'),
                            exportTime: new Date().toLocaleTimeString('es-ES')
                        }
                    };
                    
                    // Crear archivo JSON para descargar
                    const dataStr = JSON.stringify(exportData, null, 2);
                    const dataBlob = new Blob([dataStr], { type: 'application/json' });
                    
                    // Crear enlace de descarga
                    const downloadLink = document.createElement('a');
                    downloadLink.href = URL.createObjectURL(dataBlob);
                    downloadLink.download = `montajes_gaby_${new Date().toISOString().split('T')[0]}.json`;
                    
                    // Simular clic para descargar
                    document.body.appendChild(downloadLink);
                    downloadLink.click();
                    document.body.removeChild(downloadLink);
                    
                    // Mostrar mensaje de √©xito
                    this.showCopySuccess('‚úÖ Datos exportados correctamente', 3000);
                    
                } catch (error) {
                    console.error('‚ùå Error al exportar datos:', error);
                    alert('‚ùå Error al exportar datos: ' + error.message);
                }
            }
            
            // Funci√≥n para importar datos
            importData() {
                if (!this.isAuthenticated) {
                    alert('‚ùå Debes estar autenticado para importar datos');
                    return;
                }
                
                // Abrir selector de archivos
                const fileInput = document.getElementById('import-file-input');
                if (fileInput) {
                    fileInput.click();
                }
            }
            
            // Funci√≥n para encontrar el √≠ndice de datos usando la fecha como identificador
            findDataIndexByDate(fecha) {
                if (!this.sheetsData['Datos'] || this.sheetsData['Datos'].length < 2) {
                    return -1;
                }
                


                
                // Buscar en los datos (sin incluir headers)
                for (let i = 1; i < this.sheetsData['Datos'].length; i++) {
                    if (this.sheetsData['Datos'][i][0] === fecha) {
        
                        return i; // Retornar el √≠ndice real en los datos
                    }
                }
                
                console.warn(`‚ö†Ô∏è No se encontr√≥ fecha ${fecha} en los datos`);
                return -1;
            }
            
            // Funci√≥n para encontrar el √≠ndice real en los datos ordenados
            findRealDataIndex(rowData) {
                if (!this.sheetsData['Datos'] || this.sheetsData['Datos'].length < 2) {
                    return -1;
                }
                
                // Usar la fecha como identificador √∫nico
                const fecha = rowData[0];
                
                // Buscar en los datos originales (sin incluir headers)
                for (let i = 1; i < this.sheetsData['Datos'].length; i++) {
                    if (this.sheetsData['Datos'][i][0] === fecha) {
                        return i;
                    }
                }
                
                return -1;
            }
            
            // Funci√≥n helper para construir URLs de API
            getApiUrl(endpoint) {
                return `${this.baseUrl}${endpoint}`;
            }
            
            // Funci√≥n para mostrar indicador de entorno (DESHABILITADA - Autom√°tica)
            showEnvironmentIndicator() {
                // Funci√≥n deshabilitada - la detecci√≥n es autom√°tica
                return;
            }
            
            // Funci√≥n para cambiar entorno manualmente (DESHABILITADA - Autom√°tica)
            toggleEnvironment() {
                // Funci√≥n deshabilitada - la detecci√≥n es autom√°tica
                return;
            }
            
            // Funci√≥n para enviar datos importados al backend
            async sendImportedDataToBackend(data) {
                try {
    
                    
                    // Preparar datos para enviar (sin headers)
                    const montajesToSend = data.slice(1); // Excluir la primera fila (headers)
                    
    
                    
                    // Enviar todos los montajes de una vez usando el endpoint de importaci√≥n masiva
                    const response = await fetch(this.getApiUrl('/api/import-montages'), {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            montages: montajesToSend
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error(`Error del servidor: ${response.status}`);
                    }
                    
                    const result = await response.json();
                    
                    if (!result.success) {
                        throw new Error(result.error || 'Error al importar montajes');
                    }
                    
    
    
                    
                    // Recargar datos desde el backend para confirmar
                    await this.loadDataFromBackend();
                    
                    this.showCopySuccess(
                        `‚úÖ Importaci√≥n completada\nüìä ${montajesToSend.length} montajes enviados al servidor\nüîÑ Datos recargados desde el servidor`, 
                        8000
                    );
                    
                } catch (error) {
                    console.error('‚ùå Error al enviar datos al backend:', error);
                    this.showCopySuccess(
                        `‚ö†Ô∏è Error al enviar al servidor\nüìä Los datos est√°n en memoria pero no se guardaron permanentemente\n‚ùå Error: ${error.message}`, 
                        10000
                    );
                }
            }
            
            // Funci√≥n para manejar la importaci√≥n de archivos
            handleFileImport(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                if (!this.isAuthenticated) {
                    alert('‚ùå Debes estar autenticado para importar datos');
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const importedData = JSON.parse(e.target.result);
                        
                        // Validar estructura del archivo
                        if (!importedData.data || !Array.isArray(importedData.data)) {
                            throw new Error('Formato de archivo inv√°lido');
                        }
                        
                        // Confirmar importaci√≥n
                        const confirmImport = confirm(
                            `üì• ¬øImportar ${importedData.data.length - 1} montajes?\n\n` +
                            `üìÖ Fecha de exportaci√≥n: ${importedData.metadata?.exportDate || 'N/A'}\n` +
                            `‚è∞ Hora de exportaci√≥n: ${importedData.metadata?.exportTime || 'N/A'}\n\n` +
                            `‚ö†Ô∏è Esta acci√≥n sobrescribir√° los datos actuales.`
                        );
                        
                        if (confirmImport) {
            
            
                            
                            // Importar datos en memoria
                            this.sheetsData['Datos'] = importedData.data;
                            
                            // ENVIAR DATOS AL BACKEND PARA PERSISTENCIA
                            this.sendImportedDataToBackend(importedData.data);
                            
                            // Actualizar tabla en pantalla
                            this.displaySheetData('Datos');
                            
                            // Actualizar estad√≠sticas y an√°lisis
                            this.displayStats();
                            this.generateAnalysis(this.sheetsData['Datos']);
                            
                            // Mostrar mensaje de √©xito
                            this.showCopySuccess(
                                `‚úÖ Datos importados correctamente\nüìä ${importedData.data.length - 1} montajes cargados\nüîÑ Enviando al servidor...`, 
                                5000
                            );
                        }
                        
                    } catch (error) {
                        console.error('‚ùå Error al importar datos:', error);
                        alert('‚ùå Error al importar datos: ' + error.message);
                    }
                };
                
                reader.readAsText(file);
                
                // Limpiar input para permitir importar el mismo archivo
                event.target.value = '';
            }

            // Recuperar montaje eliminado por accidente
            recoverDeletedBuild() {
                const deletedBuild = [
                    '2025-08-28',           // Fecha
                    'Montaje PC 2950‚Ç¨ Invertido - 9800X3D & RTX 5080 & BeQuiet 600 LX', // T√≠tulo
                    '2950',                 // Precio
                    'AMD RYZEN 9 9800X3D', // Procesador
                    'NVIDIA RTX 5080',      // Tarjeta gr√°fica
                    'BEQUIET 600 LX'        // Torre
                ];
                
                try {
                    // Obtener entradas existentes del localStorage
                    const existingEntries = JSON.parse(localStorage.getItem('gabyLocalEntries') || '[]');
                    
                    // A√±adir la entrada recuperada al inicio
                    existingEntries.unshift(deletedBuild);
                    
                    // Guardar en localStorage
                    localStorage.setItem('gabyLocalEntries', JSON.stringify(existingEntries));
                    
                    // A√±adir la nueva fila al inicio de los datos (despu√©s de los headers)
                    if (this.sheetsData['Datos'] && this.sheetsData['Datos'].length > 0) {
                        // Insertar despu√©s de los headers (√≠ndice 1)
                        this.sheetsData['Datos'].splice(1, 0, deletedBuild);
                        
                        // Actualizar la tabla en pantalla
                        this.displaySheetData('Datos');
                        
                        // Actualizar estad√≠sticas y an√°lisis
                        this.displayStats();
                        this.generateAnalysis(this.sheetsData['Datos']);
                        
                        // Mostrar mensaje de √©xito
                        this.showCopySuccess(`‚úÖ ¬°Montaje recuperado correctamente!\nüìÖ Fecha: 2025-08-28\nüí∞ Precio: 2950‚Ç¨`, 8000);
                        
                        // Actualizar el contador de entradas locales
                        this.updateLocalEntriesCount();
                        
                    } else {
                        alert('‚ùå Error: No se pueden cargar los datos de la tabla. Recarga la p√°gina e int√©ntalo de nuevo.');
                    }
                    
                } catch (error) {
                    alert('‚ùå Error al recuperar el montaje: ' + error.message);
                }
            }

        }

        // FUNCIONES DE SCROLL OBSOLETAS ELIMINADAS - SOLO QUEDAN LAS DE FIREFOX

        // Funci√≥n para actualizar el estado de los botones de scroll (CORREGIDA)
        function updateScrollButtons() {
            const scrollUpBtn = document.getElementById('scroll-up-btn-firefox');
            const scrollDownBtn = document.getElementById('scroll-down-btn-firefox');
            
            if (!scrollUpBtn || !scrollDownBtn) return;
            
            const tableContainer = document.getElementById('main-table-firefox-container-inner');
            
            if (!tableContainer) return;
            
            const scrollTop = tableContainer.scrollTop;
            const scrollHeight = tableContainer.scrollHeight;
            const clientHeight = tableContainer.clientHeight;
            
            // Si estamos en la parte superior (primera fila), ocultar bot√≥n hacia arriba
            if (scrollTop <= 10) {
                scrollUpBtn.classList.add('date-nav-button-hidden');
                scrollUpBtn.classList.remove('date-nav-button-visible');
            } else {
                scrollUpBtn.classList.remove('date-nav-button-hidden');
                scrollUpBtn.classList.add('date-nav-button-visible');
            }
            
            // Si no hay scroll vertical, siempre mostrar la flecha de abajo
            if (scrollHeight <= clientHeight) {
                // No hay scroll vertical - siempre mostrar flecha de abajo
                scrollDownBtn.classList.remove('date-nav-button-hidden');
                scrollDownBtn.classList.add('date-nav-button-visible');
            } else if (scrollTop + clientHeight >= scrollHeight - 10) {
                // Si estamos en la parte inferior (√∫ltima fila), ocultar bot√≥n hacia abajo
                scrollDownBtn.classList.add('date-nav-button-hidden');
                scrollDownBtn.classList.remove('date-nav-button-visible');
            } else {
                scrollDownBtn.classList.remove('date-nav-button-hidden');
                scrollDownBtn.classList.add('date-nav-button-visible');
            }
        }

        // FUNCIONES DE SCROLL PARA LA NUEVA TABLA FIREFOX
        function scrollToFirstRowFirefox() {
            const tableContainer = document.getElementById('main-table-firefox-container-inner');
            
            if (tableContainer) {
                // Scroll al inicio del contenedor que tiene overflow-y: auto
                tableContainer.scrollTo({
                    top: 0,
                    behavior: 'smooth'
                });
                
                // Resaltar brevemente la primera fila
                const table = tableContainer.querySelector('table');
                if (table) {
                    const tbody = table.querySelector('tbody');
                    if (tbody && tbody.rows.length > 0) {
                        const firstRow = tbody.rows[0];
                        firstRow.style.backgroundColor = '#e3f2fd';
                        setTimeout(() => {
                            firstRow.style.backgroundColor = '';
                        }, 2000);
                    }
                }
                
                // Actualizar estado de los botones despu√©s del scroll
                setTimeout(() => {
                    updateScrollButtons();
                }, 500);
            }
        }

        function scrollToLastRowFirefox() {
            const tableContainer = document.getElementById('main-table-firefox-container-inner');
            
            if (tableContainer) {
                // Scroll al final del contenedor que tiene overflow-y: auto
                tableContainer.scrollTo({
                    top: tableContainer.scrollHeight,
                    behavior: 'smooth'
                });
                
                // Resaltar brevemente la √∫ltima fila
                const table = tableContainer.querySelector('table');
                if (table) {
                    const tbody = table.querySelector('tbody');
                    if (tbody && tbody.rows.length > 0) {
                        const lastRow = tbody.rows[tbody.rows.length - 1];
                        lastRow.style.backgroundColor = '#e3f2fd';
                        setTimeout(() => {
                            lastRow.style.backgroundColor = '';
                        }, 2000);
                    }
                }
                
                // Actualizar estado de los botones despu√©s del scroll
                setTimeout(() => {
                    updateScrollButtons();
                }, 500);
            }
        }
        
        // Inicializar la aplicaci√≥n cuando se carga la p√°gina
        document.addEventListener('DOMContentLoaded', () => {
            // Verificar que las estad√≠sticas mensuales est√©n ocultas al inicio
            const monthlyStatsWrapper = document.getElementById('monthly-stats-wrapper');
            if (monthlyStatsWrapper) {

            }
            
            window.pcBuildsViewer = new PCBuildsViewer();
            
            // Inicializar estado de los botones de scroll y agregar listener
            setTimeout(() => {
                updateScrollButtons();
                const tableContainer = document.getElementById('main-table-firefox-container-inner');
                if (tableContainer) {
                    tableContainer.addEventListener('scroll', updateScrollButtons);
                }
                

                

            }, 1000);
        });
        
        // Funci√≥n para scroll hacia arriba
        function scrollToTop() {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        }
        
        // Funci√≥n para scroll a estad√≠sticas mensuales sin cambiar URL
        function scrollToMonthlyStats() {
            const monthlyStatsSection = document.getElementById('monthly-stats-section');
            if (monthlyStatsSection) {
                monthlyStatsSection.scrollIntoView({
                    behavior: 'smooth'
                });
            }
        }
    </script>

    <!-- ESTAD√çSTICAS MENSUALES AL FINAL -->
    <div id="monthly-stats-wrapper" class="monthly-stats-wrapper hidden">
        <h2 id="monthly-stats-section" class="monthly-stats-section-title">üìÖ Estad√≠sticas Mensuales 2025</h2>
        <div id="monthly-stats-table-final" class="monthly-stats-table-container"></div>
    </div>
    
    <!-- FLECHA HACIA ARRIBA -->
    <div class="scroll-to-top-container">
        <button id="scroll-to-top-btn" class="scroll-to-top-btn" onclick="scrollToTop()">
            <span class="scroll-arrow">‚ñ≤</span>
        </button>
    </div>

    <!-- √Årea invisible de autenticaci√≥n en la esquina superior derecha -->
    <div class="auth-corner" id="auth-button" title="üîê Autenticaci√≥n"></div>
    
    <!-- Iconos de exportaci√≥n e importaci√≥n (solo visibles cuando autenticado) -->
    <div class="data-actions-corner hidden" id="data-actions-corner">
        <div class="data-action-btn" id="export-data-btn" title="üì§ Exportar datos" onclick="window.pcBuildsViewer.exportData()">
            üì§
        </div>
        <div class="data-action-btn" id="import-data-btn" title="üì• Importar datos" onclick="window.pcBuildsViewer.importData()">
            üì•
        </div>
        <input type="file" id="import-file-input" accept=".json" style="display: none;" onchange="window.pcBuildsViewer.handleFileImport(event)">
    </div>
</body>
</html>

