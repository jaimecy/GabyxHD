<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Montajes GabyxHD 2025</title>
    <link rel="stylesheet" href="styles.css">
    <script src="security.js"></script>
    
    <!-- Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-HDYP4SXL7E"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-HDYP4SXL7E');
    </script>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Montajes de GabyxHD en 2025</h1>
        </div>

        <div id="loading" class="loading">
            <span class="spinner">‚è≥</span> Conectando a Google Sheets...
        </div>

        <div id="error" class="error hidden"></div>

        <!-- Informaci√≥n de Estad√≠sticas -->
        <div id="stats-info" class="hidden">
            <h3 class="stats-title">‚ÑπÔ∏è Informaci√≥n de los Montajes</h3>
            <div id="stats-grid" class="stats-grid"></div>
            
            <!-- ENLACE A ESTAD√çSTICAS MENSUALES -->
            <div class="monthly-stats-link">
                <a href="#" onclick="scrollToMonthlyStats(); return false;">üìä Ver Estad√≠sticas Mensuales 2025</a>
            </div>
            
            <div class="stats-button-container">
                <button id="go-to-analysis-btn" class="go-to-analysis-btn">
                    üìä An√°lisis de Componentes
                </button>
            </div>
        </div>

        <!-- NUEVA TABLA CON PROPIEDADES DE COMBINATIONS-TABLE - PARA FIREFOX -->
        <div id="main-table-firefox-container" class="hidden">
            <div class="table-wrapper">
                <div id="main-table-firefox-container-inner"></div>
            </div>
        </div>

        <!-- TABLA VIEJA ELIMINADA - SOLO QUEDA LA NUEVA TABLA -->

        <!-- Secci√≥n de An√°lisis (oculta por defecto) -->
        <div id="analysis-container" class="hidden">
            <div class="back-button-container">
                <button id="back-to-data-btn" class="back-to-data-btn">
                    ‚¨ÖÔ∏è Volver a los Datos
                </button>
            </div>
            <div>
                <!-- Nueva tabla de combinaciones m√°s populares -->
                <div class="combinations-section">
                    <h3 class="combinations-title">üèÜ Top Combinaciones M√°s Populares</h3>
                    <div id="combinations-table-container" class="combinations-table-container"></div>
                </div>
                
                <h2 class="analysis-title">
                    üìä An√°lisis de Componentes Montados
                </h2>
                
                <div id="analysis-content"></div>
            </div>
            
            <!-- Bot√≥n adicional debajo del an√°lisis -->
            <div class="bottom-button-container">
                <button id="back-to-data-btn-bottom" class="back-to-data-btn">
                    ‚¨ÖÔ∏è Volver a los Datos
                </button>
            </div>
        </div>


    </div>

    <script>
        class PCBuildsViewer {
            constructor() {
                this.sheetsData = {};
                this.apiUrl = 'https://gabyxhd.onrender.com/api/sheets-data'; // Backend en Render
                this.spreadsheetId = '1OCMcUJ0VerXZLEgyjapb_lNvRZQL05lIcGf882AaTfU';
                this.maxRetries = 3;
                this.retryDelay = 2000; // 2 segundos inicial
                this.init();
            }

            async init() {
                try {
                    // Verificar conectividad primero con reintentos
                    await this.checkConnectivityWithRetry();
                    
                    await this.loadSheetData('Datos');
                    this.setupEventListeners();
                    this.hideLoading();
                } catch (error) {
                    console.error('Error en inicializaci√≥n:', error);
                    this.showError('Error al inicializar: ' + error.message);
                    this.hideLoading();
                    
                    // Mostrar bot√≥n de reintento
                    this.showRetryButton();
                }
            }

            async checkConnectivityWithRetry() {
                let lastError;
                
                for (let attempt = 1; attempt <= this.maxRetries; attempt++) {
                    try {
                        this.showLoading(`Verificando conectividad... (intento ${attempt}/${this.maxRetries})`);
                        
                        // Intentar hacer ping al servidor con timeout m√°s largo
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), 15000); // 15 segundos
                        
                        const response = await fetch(this.apiUrl + '?ping=true', {
                            signal: controller.signal,
                            method: 'HEAD'
                        });
                        
                        clearTimeout(timeoutId);
                        
                        if (!response.ok) {
                            throw new Error(`Servidor respondi√≥ con estado: ${response.status}`);
                        }
                        
                        return true;
                    } catch (error) {
                        lastError = error;
                        
                        if (error.name === 'AbortError') {
                            console.warn(`Timeout en intento ${attempt}/${this.maxRetries}`);
                            
                            if (attempt < this.maxRetries) {
                                // Esperar antes del siguiente intento con backoff exponencial
                                const delay = this.retryDelay * Math.pow(2, attempt - 1);
                                this.showLoading(`Timeout. Reintentando en ${Math.round(delay/1000)}s... (${attempt}/${this.maxRetries})`);
                                await new Promise(resolve => setTimeout(resolve, delay));
                            }
                        } else {
                            // Error de red u otro tipo
                            if (attempt < this.maxRetries) {
                                const delay = this.retryDelay * Math.pow(2, attempt - 1);
                                this.showLoading(`Error de conexi√≥n. Reintentando en ${Math.round(delay/1000)}s... (${attempt}/${this.maxRetries})`);
                                await new Promise(resolve => setTimeout(resolve, delay));
                            }
                        }
                    }
                }
                
                // Si llegamos aqu√≠, todos los intentos fallaron
                if (lastError.name === 'AbortError') {
                    throw new Error('El servidor no responde despu√©s de m√∫ltiples intentos (timeout)');
                } else {
                    throw new Error('No se puede conectar al servidor despu√©s de m√∫ltiples intentos: ' + lastError.message);
                }
            }

            async checkConnectivity() {
                try {
                    // Intentar hacer ping al servidor
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 15000); // Aumentado a 15 segundos
                    
                    const response = await fetch(this.apiUrl + '?ping=true', {
                        signal: controller.signal,
                        method: 'HEAD'
                    });
                    
                    clearTimeout(timeoutId);
                    
                    if (!response.ok) {
                        throw new Error(`Servidor respondi√≥ con estado: ${response.status}`);
                    }
                    
                    return true;
                } catch (error) {
                    if (error.name === 'AbortError') {
                        throw new Error('El servidor no responde (timeout)');
                    }
                    throw new Error('No se puede conectar al servidor: ' + error.message);
                }
            }

            showRetryButton() {
                const errorDiv = document.getElementById('error');
                if (errorDiv) {
                    errorDiv.innerHTML = `
                        <div class="error-content">
                            <p>‚ùå ${errorDiv.textContent}</p>
                            <div class="error-actions">
                                <button onclick="location.reload()" class="retry-button">
                                    üîÑ Reintentar
                                </button>
                                <button onclick="window.pcBuildsViewer.checkServerStatus()" class="status-button">
                                    üìä Estado del Servidor
                                </button>
                                <button onclick="window.pcBuildsViewer.checkConnectivityManually()" class="connectivity-button">
                                    üåê Verificar Conexi√≥n
                                </button>
                            </div>
                            <div class="error-tips">
                                <p><strong>üí° Consejos:</strong></p>
                                <ul>
                                    <li>Verifica tu conexi√≥n a internet</li>
                                    <li>El servidor puede estar temporalmente lento</li>
                                    <li>Intenta recargar la p√°gina en unos minutos</li>
                                </ul>
                            </div>
                        </div>
                    `;
                }
            }

            async checkConnectivityManually() {
                try {
                    this.showLoading('Verificando conectividad manualmente...');
                    
                    const startTime = Date.now();
                    const response = await fetch('https://gabyxhd.onrender.com/health', {
                        method: 'GET',
                        signal: AbortSignal.timeout(20000) // 20 segundos para verificaci√≥n manual
                    });
                    
                    const endTime = Date.now();
                    const responseTime = endTime - startTime;
                    
                    if (response.ok) {
                        const health = await response.json();
                        this.showError(`‚úÖ Servidor funcionando - Tiempo de respuesta: ${responseTime}ms - Uptime: ${Math.round(health.uptime / 60)} minutos`);
                    } else {
                        this.showError(`‚ö†Ô∏è Servidor respondi√≥ con estado: ${response.status} - Tiempo: ${responseTime}ms`);
                    }
                } catch (error) {
                    if (error.name === 'TimeoutError') {
                        this.showError(`‚ùå Timeout despu√©s de 20 segundos - El servidor est√° muy lento o no responde`);
                    } else {
                        this.showError(`‚ùå Error de conexi√≥n: ${error.message}`);
                    }
                } finally {
                    this.hideLoading();
                }
            }

            async checkServerStatus() {
                try {
                    this.showLoading('Verificando estado del servidor...');
                    
                    const startTime = Date.now();
                    const response = await fetch('https://gabyxhd.onrender.com/health', {
                        method: 'GET',
                        signal: AbortSignal.timeout(15000) // 15 segundos
                    });
                    const endTime = Date.now();
                    const responseTime = endTime - startTime;
                    
                    if (response.ok) {
                        const health = await response.json();
                        const uptimeMinutes = Math.round(health.uptime / 60);
                        const uptimeHours = Math.floor(uptimeMinutes / 60);
                        const remainingMinutes = uptimeMinutes % 60;
                        
                        let uptimeText = '';
                        if (uptimeHours > 0) {
                            uptimeText = `${uptimeHours}h ${remainingMinutes}m`;
                        } else {
                            uptimeText = `${uptimeMinutes}m`;
                        }
                        
                        this.showError(`‚úÖ Servidor funcionando correctamente

üìä Informaci√≥n del servidor:
‚Ä¢ Tiempo de respuesta: ${responseTime}ms
‚Ä¢ Tiempo activo: ${uptimeText}
‚Ä¢ Estado HTTP: ${response.status}
‚Ä¢ URL: gabyxhd.onrender.com`);
                    } else {
                        this.showError(`‚ö†Ô∏è Servidor respondi√≥ con estado: ${response.status}

üìä Detalles:
‚Ä¢ Tiempo de respuesta: ${responseTime}ms
‚Ä¢ Estado HTTP: ${response.status}
‚Ä¢ URL: gabyxhd.onrender.com
‚Ä¢ El servidor est√° respondiendo pero con un error`);
                    }
                } catch (error) {
                    if (error.name === 'TimeoutError') {
                        this.showError(`‚ùå Timeout - El servidor no responde en 15 segundos

üìä Diagn√≥stico:
‚Ä¢ El servidor est√° muy lento o no responde
‚Ä¢ Tiempo m√°ximo de espera: 15 segundos
‚Ä¢ URL: gabyxhd.onrender.com
‚Ä¢ Posible problema de conectividad o servidor sobrecargado`);
                    } else {
                        this.showError(`‚ùå Error de conexi√≥n: ${error.message}

üìä Diagn√≥stico:
‚Ä¢ Tipo de error: ${error.name || 'Desconocido'}
‚Ä¢ URL: gabyxhd.onrender.com
‚Ä¢ Posible problema de red o servidor inaccesible`);
                    }
                } finally {
                    this.hideLoading();
                }
            }

            async loadSheetData(sheetName) {
                let lastError;
                
                for (let attempt = 1; attempt <= this.maxRetries; attempt++) {
                    try {
                        if (attempt > 1) {
                            this.showLoading(`Cargando datos... (intento ${attempt}/${this.maxRetries})`);
                        }
                        
                        const response = await fetch(this.apiUrl, {
                            signal: AbortSignal.timeout(20000) // 20 segundos para cargar datos
                        });
                        
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        
                        const result = await response.json();
                        
                        if (!result.success) {
                            throw new Error(result.error || 'Error al obtener datos');
                        }
                        
                        // Procesar los datos del backend
                        const rows = result.data;
                        const headers = result.headers;
                        
                        if (!rows || rows.length === 0) {
                            throw new Error('No se encontraron datos en la hoja');
                        }
                        
                         // Convertir los datos al formato esperado por el frontend
                         const processedRows = rows.map(row => [
                             row['Fecha'] || '',
                             row['T√≠tulo del directo de Twitch'] || '',
                             row['Precio ‚Ç¨'] || '',
                             row['Procesador'] || '',
                             row['Tarjeta gr√°fica'] || '',
                             row['Torre'] || ''
                         ]);
                        
                        // Filtrar filas con fechas v√°lidas y ordenar por fecha decreciente
                        const validRows = processedRows.filter(row => {
                            const dateStr = row[0].trim();
                            if (!dateStr) return false;
                            
                            // Intentar diferentes formatos de fecha
                            let date = new Date(dateStr);
                            if (isNaN(date.getTime())) {
                                // Si falla, intentar con formato DD-MM-YYYY
                                const parts = dateStr.split('-');
                                if (parts.length === 3) {
                                    date = new Date(parts[2], parts[1] - 1, parts[0]);
                                }
                            }
                            
                            return !isNaN(date.getTime());
                        });
                        
                        const invalidRows = processedRows.filter(row => {
                            const dateStr = row[0].trim();
                            if (!dateStr) return false;
                            
                            let date = new Date(dateStr);
                            if (isNaN(date.getTime())) {
                                const parts = dateStr.split('-');
                                if (parts.length === 3) {
                                    date = new Date(parts[2], parts[1] - 1, parts[0]);
                                }
                            }
                            
                            return isNaN(date.getTime());
                        });
                        
                        // Ordenar filas v√°lidas por fecha decreciente (m√°s reciente primero)
                        validRows.sort((a, b) => {
                            const dateStrA = a[0].trim();
                            const dateStrB = b[0].trim();
                            
                            let dateA = new Date(dateStrA);
                            if (isNaN(dateA.getTime())) {
                                const parts = dateStrA.split('-');
                                if (parts.length === 3) {
                                    dateA = new Date(parts[2], parts[1] - 1, parts[0]);
                                }
                            }
                            
                            let dateB = new Date(dateStrB);
                            if (isNaN(dateB.getTime())) {
                                const parts = dateStrB.split('-');
                                if (parts.length === 3) {
                                    dateB = new Date(parts[2], parts[1] - 1, parts[0]);
                                }
                            }
                            
                            return dateB - dateA; // Orden decreciente
                        });
                        

                        
                        // Agregar filas inv√°lidas al final (sin ordenar)
                        const finalRows = [...validRows, ...invalidRows];
                        
                        // Crear un nuevo array con las filas finales
                        const finalData = [headers, ...finalRows];
                        
                        this.sheetsData[sheetName] = finalData;
                        this.displaySheetData(sheetName);
                        this.displayStats();
                        this.generateAnalysis(finalData);
                        
                        return; // Salir del bucle si todo va bien
                        
                    } catch (error) {
                        lastError = error;
                        
                        if (error.name === 'TimeoutError') {
                            console.warn(`Timeout al cargar datos en intento ${attempt}/${this.maxRetries}`);
                            
                            if (attempt < this.maxRetries) {
                                // Esperar antes del siguiente intento con backoff exponencial
                                const delay = this.retryDelay * Math.pow(2, attempt - 1);
                                this.showLoading(`Timeout al cargar datos. Reintentando en ${Math.round(delay/1000)}s... (${attempt}/${this.maxRetries})`);
                                await new Promise(resolve => setTimeout(resolve, delay));
                            }
                        } else {
                            // Error de red u otro tipo
                            if (attempt < this.maxRetries) {
                                const delay = this.retryDelay * Math.pow(2, attempt - 1);
                                this.showLoading(`Error al cargar datos. Reintentando en ${Math.round(delay/1000)}s... (${attempt}/${this.maxRetries})`);
                                await new Promise(resolve => setTimeout(resolve, delay));
                            }
                        }
                    }
                }
                
                // Si llegamos aqu√≠, todos los intentos fallaron
                throw new Error('Error al cargar datos de la hoja despu√©s de m√∫ltiples intentos: ' + lastError.message);
            }

            generateAnalysis(data) {
                if (!data || data.length < 2) return;
                
                const rows = data.slice(1); // Excluir la fila de headers
                const processors = {};
                const graphics = {};
                const cases = {};
                const combinations = {};

                                 // √çndices de las columnas
                 const priceIndex = 2; // Precio ‚Ç¨
                const processorIndex = 3; // Procesador
                const graphicsIndex = 4; // Tarjeta gr√°fica
                const caseIndex = 5; // Torre

                rows.forEach(row => {
                    // An√°lisis de procesadores
                    const processorItem = row[processorIndex];
                    if (processorItem && processorItem.trim() !== '') {
                        const cleanProcessor = processorItem.trim();
                        processors[cleanProcessor] = (processors[cleanProcessor] || 0) + 1;
                    }

                    // An√°lisis de tarjetas gr√°ficas
                    const graphicsItem = row[graphicsIndex];
                    if (graphicsItem && graphicsItem.trim() !== '') {
                        const cleanGraphics = graphicsItem.trim();
                        graphics[cleanGraphics] = (graphics[cleanGraphics] || 0) + 1;
                    }

                    // An√°lisis de torres
                    const caseItem = row[caseIndex];
                    if (caseItem && caseItem.trim() !== '') {
                        const cleanCase = caseItem.trim();
                        cases[cleanCase] = (cases[cleanCase] || 0) + 1;
                    }

                    // An√°lisis de combinaciones (procesador + gr√°fica + torre)
                    if (processorItem && graphicsItem && caseItem) {
                        const cleanProcessor = processorItem.trim();
                        const cleanGraphics = graphicsItem.trim();
                        const cleanCase = caseItem.trim();
                        
                        if (cleanProcessor && cleanGraphics && cleanCase) {
                            const combinationKey = `${cleanProcessor}|${cleanGraphics}|${cleanCase}`;
                            combinations[combinationKey] = (combinations[combinationKey] || 0) + 1;
                        }
                    }
                });

                // An√°lisis de precios
                const prices = rows.map(row => parseFloat(row[priceIndex])).filter(p => !isNaN(p));
                const avgPrice = prices.length > 0 ? prices.reduce((a, b) => a + b, 0) / prices.length : 0;
                const minPrice = Math.min(...prices);
                const maxPrice = Math.max(...prices);

                this.displayAnalysis(processors, graphics, cases, { avg: avgPrice, min: minPrice, max: maxPrice, total: rows.length });
                this.displayCombinationsTable(combinations);
            }

            displayAnalysis(processors, graphics, cases, prices) {
                // Crear contenido del an√°lisis
                const analysisContent = document.getElementById('analysis-content');
                
                analysisContent.innerHTML = `
                    <div class="analysis-grid">
                        <div class="processor-section">
                            <h3 class="section-title">
                                Procesadores
                            </h3>
                            ${this.generateAnalysisTable(processors, 'Procesador', 'processor')}
                        </div>
                        
                        <div class="graphics-section">
                            <h3 class="section-title">
                                Tarjetas Gr√°ficas
                            </h3>
                            ${this.generateAnalysisTable(graphics, 'Tarjeta Gr√°fica', 'graphics')}
                        </div>
                        
                        <div class="tower-section">
                            <h3 class="section-title">
                                Torres
                            </h3>
                            ${this.generateAnalysisTable(cases, 'Torre', 'case')}
                        </div>
                    </div>
                    
                    <div class="prices-section">
                        <h3 class="prices-title">
                            Resumen de Precios de PCs
                        </h3>
                        <div class="cost-explanation">(El precio es de todos los componentes)</div>
                        <div class="prices-grid">
                            <div class="price-card">
                                <div class="price-value price-avg">${Math.round(prices.avg)}‚Ç¨</div>
                                <div class="price-label">Precio Promedio</div>
                            </div>
                            <div class="price-card">
                                <div class="price-value price-min">${prices.min}‚Ç¨</div>
                                <div class="price-label">Precio M√≠nimo</div>
                            </div>
                            <div class="price-card">
                                <div class="price-value price-max">${prices.max}‚Ç¨</div>
                                <div class="price-label">Precio M√°ximo</div>
                            </div>
                        </div>
                    </div>
                `;
            }

            displayCombinationsTable(combinations) {
                const combinationsContainer = document.getElementById('combinations-table-container');
                
                if (!combinations || Object.keys(combinations).length === 0) {
                    combinationsContainer.innerHTML = '<p class="no-combinations">No hay combinaciones disponibles para mostrar.</p>';
                    return;
                }

                // Convertir combinaciones a array, filtrar las que solo se usaron una vez y ordenar por n√∫mero de veces usado (de mayor a menor)
                const sortedCombinations = Object.entries(combinations)
                    .filter(([, count]) => count > 1) // Solo combinaciones usadas m√°s de una vez
                    .sort(([, countA], [, countB]) => countB - countA)
                    .slice(0, 20); // Mostrar solo las top 20 combinaciones

                let tableHTML = `
                    <div class="analysis-table-container">
                        <table class="combinations-table" style="width: 820px !important; table-layout: fixed !important;">
                            <thead>
                                <tr>
                                    <th style="width: 120px !important; min-width: 120px !important; max-width: 120px !important;">N¬∞ veces</th>
                                    <th style="width: 200px !important; min-width: 200px !important; max-width: 200px !important;">Procesador</th>
                                    <th style="width: 200px !important; min-width: 200px !important; max-width: 200px !important;">Gr√°fica</th>
                                    <th style="width: 300px !important; min-width: 300px !important; max-width: 300px !important;">Torre</th>
                                </tr>
                            </thead>
                            <tbody>
                `;

                sortedCombinations.forEach(([combinationKey, count], index) => {
                    const [processor, graphics, case_] = combinationKey.split('|');
                    const rowClass = index % 2 === 0 ? 'combinations-row combinations-row-even' : 'combinations-row combinations-row-odd';
                    
                    tableHTML += `
                        <tr class="${rowClass}">
                            <td class="combinations-count" style="width: 120px !important; min-width: 120px !important; max-width: 120px !important; text-align: center !important;">${count}</td>
                            <td class="combinations-processor" style="width: 200px !important; min-width: 200px !important; max-width: 200px !important; text-align: center !important;">${processor}</td>
                            <td class="combinations-graphics" style="width: 200px !important; min-width: 200px !important; max-width: 200px !important; text-align: center !important;">${graphics}</td>
                            <td class="combinations-case" style="width: 300px !important; min-width: 300px !important; max-width: 300px !important; text-align: center !important;">${case_}</td>
                        </tr>
                    `;
                });

                tableHTML += '</tbody></table></div>';
                
                combinationsContainer.innerHTML = tableHTML;
            }

            generateAnalysisTable(data, title, type) {
                const sortedData = Object.entries(data)
                    .sort(([nameA, countA], [nameB, countB]) => {
                        if (countB !== countA) {
                            return countB - countA; // Primero por cantidad (de mayor a menor)
                        }
                        return nameA.localeCompare(nameB); // Luego alfab√©ticamente en empates
                    });

                let tableHTML = `
                    <div class="analysis-table-container">
                        <table class="analysis-table">
                            <thead>
                                <tr>
                                    <th>${title}</th>
                                    <th>N¬∞ veces</th>
                                    <th>%</th>
                                </tr>
                            </thead>
                            <tbody>
                `;

                const total = Object.values(data).reduce((sum, count) => sum + count, 0);

                sortedData.forEach(([name, count], index) => {
                    const percentage = ((count / total) * 100).toFixed(1);
                    const rowClass = index % 2 === 0 ? 'analysis-row analysis-row-even' : 'analysis-row analysis-row-odd';
                    
                    tableHTML += `
                        <tr class="${rowClass}">
                            <td>${name}</td>
                            <td>${count}</td>
                            <td>${percentage}%</td>
                        </tr>
                    `;
                });

                tableHTML += '</tbody></table></div>';
                
                // Agregar resumen del total de componentes distintos
                const uniqueComponents = Object.keys(data).length;
                const totalUsage = total;
                
                tableHTML += `
                    <div class="analysis-summary">
                        <span class="analysis-summary-text">${uniqueComponents} componentes distintos</span> | 
                        <span class="analysis-summary-text">Cantidad total: ${totalUsage}</span>
                    </div>
                `;
                

                
                return tableHTML;
            }







            setupEventListeners() {
                document.getElementById('go-to-analysis-btn').onclick = () => this.showAnalysis();
                document.getElementById('back-to-data-btn').onclick = () => this.showData();
                document.getElementById('back-to-data-btn-bottom').onclick = () => this.showData(); // Add listener for the new button
                
                // Event listener para mostrar/ocultar estad√≠sticas mensuales
                const monthlyStatsTitle = document.getElementById('monthly-stats-title');
                if (monthlyStatsTitle) {
                    monthlyStatsTitle.onclick = () => this.toggleMonthlyStats();
                }
            }

            showAnalysis() {
                // Asegurar que el an√°lisis est√© generado
                if (this.sheetsData['Datos'] && this.sheetsData['Datos'].length > 1) {
                    this.generateAnalysis(this.sheetsData['Datos']);
                }
                
                // OCULTAR COMPLETAMENTE la secci√≥n de datos y estad√≠sticas
                document.getElementById('main-table-firefox-container').style.display = 'none';
                document.getElementById('stats-info').style.display = 'none';
                
                // OCULTAR las estad√≠sticas mensuales
                const monthlyStatsWrapper = document.querySelector('.monthly-stats-wrapper');
                if (monthlyStatsWrapper) {
                    monthlyStatsWrapper.style.display = 'none';
                }
                
                // MOSTRAR SOLO la secci√≥n de an√°lisis
                document.getElementById('analysis-container').style.display = 'block';
                document.getElementById('analysis-container').classList.add('hidden');
                
                // Desplazarse al inicio de la p√°gina
                setTimeout(() => {
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                }, 100);
                
                // Alternativa si el scroll suave no funciona
                setTimeout(() => {
                    if (window.pageYOffset > 0) {
                        window.scrollTo(0, 0);
                    }
                }, 500);
            }

            showData() {
                // OCULTAR la secci√≥n de an√°lisis
                document.getElementById('analysis-container').style.display = 'none';
                document.getElementById('analysis-container').classList.add('hidden');
                
                // MOSTRAR la secci√≥n de datos y estad√≠sticas
                document.getElementById('main-table-firefox-container').style.display = 'block';
                document.getElementById('stats-info').style.display = 'block';
                
                // MOSTRAR las estad√≠sticas mensuales
                const monthlyStatsWrapper = document.querySelector('.monthly-stats-wrapper');
                if (monthlyStatsWrapper) {
                    monthlyStatsWrapper.style.display = 'block';
                }
                
                // Desplazarse arriba del todo - FORZAR el scroll
                setTimeout(() => {
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                }, 100);
                
                // Alternativa si el scroll suave no funciona
                setTimeout(() => {
                    if (window.pageYOffset > 0) {
                        window.scrollTo(0, 0);
                    }
                }, 500);
            }



            showLoading(message) {
                document.getElementById('loading').innerHTML = `‚è≥ ${message}`;
                document.getElementById('loading').style.display = 'block';
            }

            hideLoading() {
                document.getElementById('loading').style.display = 'none';
            }

            showError(message) {
                document.getElementById('loading').style.display = 'none';
                document.getElementById('error').textContent = message;
                document.getElementById('error').classList.remove('hidden');
            }

            displayStats() {
                const data = this.sheetsData['Datos'];
                if (!data || data.length < 2) return;

                const totalRows = data.length - 1; // Excluir headers
                const uniqueProcessors = new Set();
                const uniqueGraphics = new Set();
                const uniqueCases = new Set();

                // Contar componentes distintos
                data.slice(1).forEach(row => {
                    if (row[3] && row[3].trim()) uniqueProcessors.add(row[3].trim());
                    if (row[4] && row[4].trim()) uniqueGraphics.add(row[4].trim());
                    if (row[5] && row[5].trim()) uniqueCases.add(row[5].trim());
                });

                const statsGrid = document.getElementById('stats-grid');
                statsGrid.innerHTML = `
                    <div class="stat-card">
                        <div class="number">${totalRows}</div>
                        <div class="label">Montajes</div>
                    </div>
                    <div class="stat-card">
                        <div class="number">${uniqueProcessors.size}</div>
                        <div class="label">Procesadores distintos</div>
                    </div>
                    <div class="stat-card">
                        <div class="number">${uniqueGraphics.size}</div>
                        <div class="label">Tarjetas Gr√°ficas distintas</div>
                    </div>
                    <div class="stat-card">
                        <div class="number">${uniqueCases.size}</div>
                        <div class="label">Torres distintas</div>
                    </div>
                `;

                // Generar estad√≠sticas mensuales
                this.displayMonthlyStats(data);

                document.getElementById('stats-info').classList.remove('hidden');
                document.getElementById('main-table-firefox-container').style.display = 'block';
            }

            displaySheetData(sheetName) {
                const data = this.sheetsData[sheetName];
                if (!data || data.length === 0) {
                    document.getElementById('main-table-firefox-container-inner').innerHTML = '<p>No hay datos en esta hoja.</p>';
                    return;
                }

                const headers = data[0];
                const rows = data.slice(1);

                // GENERAR SOLO LA NUEVA TABLA
                let tableHTMLFirefox = '<table class="main-table-firefox"><thead><tr>';
                headers.forEach((header, headerIndex) => {
                    if (headerIndex === 0) { // Columna de Fecha
                        tableHTMLFirefox += `<th class="sortable-header" onclick="window.pcBuildsViewer.sortTable(0)">
                            <div class="sortable-header-content">
                                <span class="header-text">${header}</span>
                                <div class="sort-indicator">
                                    <span class="sort-arrow sort-arrow-up">‚ñ≤</span>
                                    <span class="sort-arrow sort-arrow-down">‚ñº</span>
                                </div>
                            </div>
                        </th>`;
                    } else if (headerIndex === 2) { // Tercera columna - Precio en ‚Ç¨
                        tableHTMLFirefox += `<th class="sortable-header" onclick="window.pcBuildsViewer.sortTable(2)">
                            <div class="sortable-header-content">
                                <span class="header-text">Precio ‚Ç¨*</span>
                                <div class="sort-indicator">
                                    <span class="sort-arrow sort-arrow-up">‚ñ≤</span>
                                    <span class="sort-arrow sort-arrow-down">‚ñº</span>
                                </div>
                            </div>
                        </th>`;
                    } else {
                        tableHTMLFirefox += `<th>${header}</th>`;
                    }
                });
                tableHTMLFirefox += '</tr></thead><tbody>';

                rows.forEach((row, index) => {
                    tableHTMLFirefox += '<tr>';
                    headers.forEach((header, cellIndex) => {
                        const cellValue = row[cellIndex] || '';
                        tableHTMLFirefox += `<td>${cellValue}</td>`;
                    });
                    tableHTMLFirefox += '</tr>';
                });

                tableHTMLFirefox += '</tbody></table>';
                document.getElementById('main-table-firefox-container-inner').innerHTML = tableHTMLFirefox;
                
                // A√±adir el mensaje explicativo FUERA del contenedor de la tabla
                const tableWrapper = document.querySelector('.table-wrapper');
                if (tableWrapper) {
                    const existingMessage = tableWrapper.nextElementSibling;
                    if (!existingMessage || !existingMessage.classList.contains('price-explanation')) {
                        const messageElement = document.createElement('p');
                        messageElement.className = 'price-explanation';
                        messageElement.textContent = '* El precio es de todos los componentes.';
                        tableWrapper.parentNode.insertBefore(messageElement, tableWrapper.nextSibling);
                    }
                }
                
                // Actualizar estado inicial de los botones de scroll
                setTimeout(() => {
                    if (typeof updateScrollButtons === 'function') {
                        updateScrollButtons();
                    }
                }, 100);
            }

            // M√©todo para ordenar la tabla por columna
            sortTable(columnIndex) {
                const data = this.sheetsData['Datos'];
                if (!data || data.length < 2) return;

                const headers = data[0];
                const rows = data.slice(1);
                
                // Obtener el estado actual de ordenamiento para esta columna
                const currentSortState = this.getSortState(columnIndex);
                const newSortDirection = currentSortState === 'asc' ? 'desc' : 'asc';
                
                // Ordenar las filas
                const sortedRows = this.sortRows(rows, columnIndex, newSortDirection);
                
                // Actualizar el estado de ordenamiento
                this.setSortState(columnIndex, newSortDirection);
                
                // Actualizar los indicadores visuales
                this.updateSortIndicators(columnIndex, newSortDirection);
                
                // Recrear la tabla con los datos ordenados
                const newData = [headers, ...sortedRows];
                this.sheetsData['Datos'] = newData;
                this.displaySheetData('Datos');
                
                // Mostrar mensaje de confirmaci√≥n
                const columnName = columnIndex === 0 ? 'Fecha' : 'Precio';
                const direction = newSortDirection === 'asc' ? 'ascendente' : 'descendente';
                this.showSortConfirmation(columnName, direction);
            }

            // Obtener el estado actual de ordenamiento para una columna
            getSortState(columnIndex) {
                if (!this.sortStates) this.sortStates = {};
                return this.sortStates[columnIndex] || null;
            }

            // Establecer el estado de ordenamiento para una columna
            setSortState(columnIndex, direction) {
                if (!this.sortStates) this.sortStates = {};
                this.sortStates[columnIndex] = direction;
            }

            // Ordenar las filas seg√∫n la columna y direcci√≥n
            sortRows(rows, columnIndex, direction) {
                return [...rows].sort((a, b) => {
                    let valueA = a[columnIndex];
                    let valueB = b[columnIndex];

                    if (columnIndex === 0) { // Columna de Fecha
                        // Convertir fechas a objetos Date para comparaci√≥n
                        valueA = this.parseDate(valueA);
                        valueB = this.parseDate(valueB);
                        
                        if (direction === 'asc') {
                            return valueA - valueB;
                        } else {
                            return valueB - valueA;
                        }
                    } else if (columnIndex === 2) { // Columna de Precio
                        // Convertir precios a n√∫meros para comparaci√≥n
                        valueA = this.parsePrice(valueA);
                        valueB = this.parsePrice(valueB);
                        
                        if (direction === 'asc') {
                            return valueA - valueB;
                        } else {
                            return valueB - valueA;
                        }
                    }
                    
                    return 0;
                });
            }

            // Parsear fecha en diferentes formatos
            parseDate(dateStr) {
                if (!dateStr || !dateStr.trim()) return new Date(0);
                
                // Intentar formato est√°ndar
                let date = new Date(dateStr);
                if (!isNaN(date.getTime())) return date;
                
                // Intentar formato DD-MM-YYYY
                const parts = dateStr.split('-');
                if (parts.length === 3) {
                    date = new Date(parts[2], parts[1] - 1, parts[0]);
                    if (!isNaN(date.getTime())) return date;
                }
                
                // Si no se puede parsear, retornar fecha m√≠nima
                return new Date(0);
            }

            // Parsear precio a n√∫mero
            parsePrice(priceStr) {
                if (!priceStr || !priceStr.trim()) return 0;
                
                // Remover s√≠mbolos de moneda y espacios
                const cleanPrice = priceStr.toString().replace(/[‚Ç¨\s,]/g, '');
                const price = parseFloat(cleanPrice);
                
                return isNaN(price) ? 0 : price;
            }

            // Actualizar indicadores visuales de ordenamiento
            updateSortIndicators(columnIndex, direction) {
                // Resetear todos los indicadores
                const allHeaders = document.querySelectorAll('.sortable-header');
                allHeaders.forEach(header => {
                    const upArrow = header.querySelector('.sort-arrow-up');
                    const downArrow = header.querySelector('.sort-arrow-down');
                    
                    if (upArrow && downArrow) {
                        upArrow.classList.remove('active');
                        downArrow.classList.remove('active');
                    }
                });
                
                // Activar el indicador correcto para la columna actual
                const currentHeader = document.querySelectorAll('.sortable-header')[columnIndex];
                if (currentHeader) {
                    const upArrow = currentHeader.querySelector('.sort-arrow-up');
                    const downArrow = currentHeader.querySelector('.sort-arrow-down');
                    
                    if (direction === 'asc' && upArrow) {
                        upArrow.classList.add('active');
                    } else if (direction === 'desc' && downArrow) {
                        downArrow.classList.add('active');
                    }
                }
            }

            // Mostrar confirmaci√≥n de ordenamiento
            showSortConfirmation(columnName, direction) {
                const message = `üìä Tabla ordenada por ${columnName} en orden ${direction}`;
                
                // Crear o actualizar el mensaje de confirmaci√≥n
                let confirmationDiv = document.querySelector('.sort-confirmation');
                if (!confirmationDiv) {
                    confirmationDiv = document.createElement('div');
                    confirmationDiv.className = 'sort-confirmation';
                    document.querySelector('.table-wrapper').parentNode.insertBefore(confirmationDiv, document.querySelector('.table-wrapper').nextSibling);
                }
                
                confirmationDiv.textContent = message;
                confirmationDiv.style.display = 'block';
                
                // Ocultar el mensaje despu√©s de 3 segundos
                setTimeout(() => {
                    confirmationDiv.style.display = 'none';
                }, 3000);
            }

            // Generar estad√≠sticas mensuales
            displayMonthlyStats(data) {
                const monthlyStats = this.calculateMonthlyStats(data);
                const monthlyStatsTable = document.getElementById('monthly-stats-table-final');
                
                if (monthlyStats.length === 0) {
                    monthlyStatsTable.innerHTML = '<p class="no-monthly-data">No hay datos suficientes para estad√≠sticas mensuales.</p>';
                    return;
                }

                let monthlyHTML = `
                    <table class="monthly-stats-table">
                        <thead>
                            <tr>
                                <th>Mes</th>
                                <th>N¬∞ Montajes</th>
                                <th>Promedio ‚Ç¨</th>
                            </tr>
                        </thead>
                        <tbody>
                `;

                monthlyStats.forEach(monthData => {
                    const monthName = this.getMonthName(monthData.month);
                    const avgPrice = Math.round(monthData.avgPrice);
                    
                    monthlyHTML += `
                        <tr>
                            <td>${monthName}</td>
                            <td>${monthData.count}</td>
                            <td>${avgPrice}</td>
                        </tr>
                    `;
                });

                monthlyHTML += '</tbody></table>';
                monthlyStatsTable.innerHTML = monthlyHTML;
            }

            // Calcular estad√≠sticas mensuales
            calculateMonthlyStats(data) {
                const monthlyData = {};
                
                // Procesar cada fila de datos (excluyendo headers)
                data.slice(1).forEach(row => {
                    const dateStr = row[0]; // Primera columna es la fecha
                    const priceStr = row[2]; // Tercera columna es el precio
                    
                    if (!dateStr || !priceStr) return;
                    
                    const date = this.parseDate(dateStr);
                    if (!date || isNaN(date.getTime())) return;
                    
                    const month = date.getMonth();
                    const year = date.getFullYear();
                    const monthKey = `${year}-${month}`;
                    
                    const price = this.parsePrice(priceStr);
                    if (isNaN(price)) return;
                    
                    if (!monthlyData[monthKey]) {
                        monthlyData[monthKey] = {
                            month: month,
                            year: year,
                            count: 0,
                            totalPrice: 0
                        };
                    }
                    
                    monthlyData[monthKey].count++;
                    monthlyData[monthKey].totalPrice += price;
                });
                
                // Calcular promedios
                Object.values(monthlyData).forEach(monthData => {
                    monthData.avgPrice = monthData.totalPrice / monthData.count;
                });
                
                // Ordenar por fecha (de menor a mayor mes del a√±o)
                return Object.values(monthlyData)
                    .sort((a, b) => {
                        if (a.year !== b.year) return a.year - b.year;
                        return a.month - b.month;
                    });
            }

            // Obtener nombre del mes en espa√±ol
            getMonthName(monthIndex) {
                const months = [
                    'Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio',
                    'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'
                ];
                return months[monthIndex];
            }



        }

        // FUNCIONES DE SCROLL OBSOLETAS ELIMINADAS - SOLO QUEDAN LAS DE FIREFOX

        // Funci√≥n para actualizar el estado de los botones de scroll (CORREGIDA)
        function updateScrollButtons() {
            const scrollUpBtn = document.getElementById('scroll-up-btn-firefox');
            const scrollDownBtn = document.getElementById('scroll-down-btn-firefox');
            
            if (!scrollUpBtn || !scrollDownBtn) return;
            
            const tableContainer = document.getElementById('main-table-firefox-container-inner');
            
            if (!tableContainer) return;
            
            const scrollTop = tableContainer.scrollTop;
            const scrollHeight = tableContainer.scrollHeight;
            const clientHeight = tableContainer.clientHeight;
            
            // Si estamos en la parte superior (primera fila), ocultar bot√≥n hacia arriba
            if (scrollTop <= 10) {
                scrollUpBtn.classList.add('date-nav-button-hidden');
                scrollUpBtn.classList.remove('date-nav-button-visible');
            } else {
                scrollUpBtn.classList.remove('date-nav-button-hidden');
                scrollUpBtn.classList.add('date-nav-button-visible');
            }
            
            // Si no hay scroll vertical, siempre mostrar la flecha de abajo
            if (scrollHeight <= clientHeight) {
                // No hay scroll vertical - siempre mostrar flecha de abajo
                scrollDownBtn.classList.remove('date-nav-button-hidden');
                scrollDownBtn.classList.add('date-nav-button-visible');
            } else if (scrollTop + clientHeight >= scrollHeight - 10) {
                // Si estamos en la parte inferior (√∫ltima fila), ocultar bot√≥n hacia abajo
                scrollDownBtn.classList.add('date-nav-button-hidden');
                scrollDownBtn.classList.remove('date-nav-button-visible');
            } else {
                scrollDownBtn.classList.remove('date-nav-button-hidden');
                scrollDownBtn.classList.add('date-nav-button-visible');
            }
        }

        // FUNCIONES DE SCROLL PARA LA NUEVA TABLA FIREFOX
        function scrollToFirstRowFirefox() {
            const tableContainer = document.getElementById('main-table-firefox-container-inner');
            
            if (tableContainer) {
                // Scroll al inicio del contenedor que tiene overflow-y: auto
                tableContainer.scrollTo({
                    top: 0,
                    behavior: 'smooth'
                });
                
                // Resaltar brevemente la primera fila
                const table = tableContainer.querySelector('table');
                if (table) {
                    const tbody = table.querySelector('tbody');
                    if (tbody && tbody.rows.length > 0) {
                        const firstRow = tbody.rows[0];
                        firstRow.style.backgroundColor = '#e3f2fd';
                        setTimeout(() => {
                            firstRow.style.backgroundColor = '';
                        }, 2000);
                    }
                }
                
                // Actualizar estado de los botones despu√©s del scroll
                setTimeout(() => {
                    updateScrollButtons();
                }, 500);
            }
        }

        function scrollToLastRowFirefox() {
            const tableContainer = document.getElementById('main-table-firefox-container-inner');
            
            if (tableContainer) {
                // Scroll al final del contenedor que tiene overflow-y: auto
                tableContainer.scrollTo({
                    top: tableContainer.scrollHeight,
                    behavior: 'smooth'
                });
                
                // Resaltar brevemente la √∫ltima fila
                const table = tableContainer.querySelector('table');
                if (table) {
                    const tbody = table.querySelector('tbody');
                    if (tbody && tbody.rows.length > 0) {
                        const lastRow = tbody.rows[tbody.rows.length - 1];
                        lastRow.style.backgroundColor = '#e3f2fd';
                        setTimeout(() => {
                            lastRow.style.backgroundColor = '';
                        }, 2000);
                    }
                }
                
                // Actualizar estado de los botones despu√©s del scroll
                setTimeout(() => {
                    updateScrollButtons();
                }, 500);
            }
        }
        
        // Inicializar la aplicaci√≥n cuando se carga la p√°gina
        document.addEventListener('DOMContentLoaded', () => {
            window.pcBuildsViewer = new PCBuildsViewer();
            
            // Inicializar estado de los botones de scroll y agregar listener
            setTimeout(() => {
                updateScrollButtons();
                const tableContainer = document.getElementById('main-table-firefox-container-inner');
                if (tableContainer) {
                    tableContainer.addEventListener('scroll', updateScrollButtons);
                }
                

            }, 1000);
        });
        
        // Funci√≥n para scroll hacia arriba
        function scrollToTop() {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        }
        
        // Funci√≥n para scroll a estad√≠sticas mensuales sin cambiar URL
        function scrollToMonthlyStats() {
            const monthlyStatsSection = document.getElementById('monthly-stats-section');
            if (monthlyStatsSection) {
                monthlyStatsSection.scrollIntoView({
                    behavior: 'smooth'
                });
            }
        }
    </script>

    <!-- ESTAD√çSTICAS MENSUALES AL FINAL -->
    <div class="monthly-stats-wrapper">
        <h2 id="monthly-stats-section" class="monthly-stats-section-title">üìÖ Estad√≠sticas Mensuales 2025</h2>
        <div id="monthly-stats-table-final" class="monthly-stats-table-container"></div>
    </div>
    
    <!-- FLECHA HACIA ARRIBA -->
    <div class="scroll-to-top-container">
        <button id="scroll-to-top-btn" class="scroll-to-top-btn" onclick="scrollToTop()">
            <span class="scroll-arrow">‚ñ≤</span>
        </button>
    </div>
</body>
</html>

