<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Montajes GabyxHD 2025</title>
    <link rel="stylesheet" href="styles.css">
    <script src="security.js"></script>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Montajes de GabyxHD en 2025</h1>
        </div>

        <div id="loading" class="loading">
            <span class="spinner">‚è≥</span> Conectando a Google Sheets...
        </div>

        <div id="error" class="error hidden"></div>

        <!-- Informaci√≥n de Estad√≠sticas -->
        <div id="stats-info" class="hidden">
            <h3 class="stats-title">‚ÑπÔ∏è Informaci√≥n de los Montajes</h3>
            <div id="stats-grid" class="stats-grid"></div>
            <div class="stats-button-container">
                <button id="go-to-analysis-btn" class="go-to-analysis-btn">
                    üìä An√°lisis de Componentes
                </button>
            </div>
        </div>

        <!-- Tabla de Datos -->
        <div id="data-container" class="hidden">
            <div class="table-wrapper">
                <div id="table-container"></div>
            </div>
        </div>

        <!-- Secci√≥n de An√°lisis (oculta por defecto) -->
        <div id="analysis-container" class="hidden">
            <div class="back-button-container">
                <button id="back-to-data-btn" class="back-to-data-btn">
                    ‚¨ÖÔ∏è Volver a los Datos
                </button>
            </div>
            <div>
                <!-- Nueva tabla de combinaciones m√°s populares -->
                <div class="combinations-section">
                    <h3 class="combinations-title">üèÜ Top Combinaciones M√°s Populares</h3>
                    <div id="combinations-table-container" class="combinations-table-container"></div>
                </div>
                
                <h2 class="analysis-title">
                    üìä An√°lisis de Componentes Montados
                </h2>
                
                <div id="analysis-content"></div>
            </div>
            
            <!-- Bot√≥n adicional debajo del an√°lisis -->
            <div class="bottom-button-container">
                <button id="back-to-data-btn-bottom" class="back-to-data-btn">
                    ‚¨ÖÔ∏è Volver a los Datos
                </button>
            </div>
        </div>


    </div>

    <script>
        class PCBuildsViewer {
            constructor() {
                this.sheetsData = {};
                this.apiUrl = 'https://gabyxhd-production.up.railway.app/api/sheets-data'; // Backend en Railway
                this.spreadsheetId = '1OCMcUJ0VerXZLEgyjapb_lNvRZQL05lIcGf882AaTfU';
                this.init();
            }

            async init() {
                try {
                    await this.loadSheetData('Datos');
                    this.setupEventListeners();
                    this.hideLoading();
                } catch (error) {
                    this.showError('Error al inicializar: ' + error.message);
                    this.hideLoading();
                }
            }

            async loadSheetData(sheetName) {
                try {
                    const response = await fetch(this.apiUrl);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    const result = await response.json();
                    
                    if (!result.success) {
                        throw new Error(result.error || 'Error al obtener datos');
                    }
                    
                    // Procesar los datos del backend
                    const rows = result.data;
                    const headers = result.headers;
                    
                    if (!rows || rows.length === 0) {
                        throw new Error('No se encontraron datos en la hoja');
                    }
                    
                    // Convertir los datos al formato esperado por el frontend
                    const processedRows = rows.map(row => [
                        row['Fecha'] || '',
                        row['T√≠tulo del directo de Twitch'] || '',
                        row['Precio en ‚Ç¨'] || '',
                        row['Procesador'] || '',
                        row['Tarjeta gr√°fica'] || '',
                        row['Torre'] || ''
                    ]);
                    
                    // Filtrar filas con fechas v√°lidas y ordenar por fecha decreciente
                    const validRows = processedRows.filter(row => {
                        const dateStr = row[0].trim();
                        if (!dateStr) return false;
                        
                        // Intentar diferentes formatos de fecha
                        let date = new Date(dateStr);
                        if (isNaN(date.getTime())) {
                            // Si falla, intentar con formato DD-MM-YYYY
                            const parts = dateStr.split('-');
                            if (parts.length === 3) {
                                date = new Date(parts[2], parts[1] - 1, parts[0]);
                            }
                        }
                        
                        return !isNaN(date.getTime());
                    });
                    
                    const invalidRows = processedRows.filter(row => {
                        const dateStr = row[0].trim();
                        if (!dateStr) return true;
                        
                        let date = new Date(dateStr);
                        if (isNaN(date.getTime())) {
                            const parts = dateStr.split('-');
                            if (parts.length === 3) {
                                date = new Date(parts[2], parts[1] - 1, parts[0]);
                            }
                        }
                        
                        return isNaN(date.getTime());
                    });
                    
                    // Ordenar filas v√°lidas por fecha decreciente (m√°s reciente primero)
                    validRows.sort((a, b) => {
                        const dateStrA = a[0].trim();
                        const dateStrB = b[0].trim();
                        
                        let dateA = new Date(dateStrA);
                        if (isNaN(dateA.getTime())) {
                            const parts = dateStrA.split('-');
                            if (parts.length === 3) {
                                dateA = new Date(parts[2], parts[1] - 1, parts[0]);
                            }
                        }
                        
                        let dateB = new Date(dateStrB);
                        if (isNaN(dateB.getTime())) {
                            const parts = dateStrB.split('-');
                            if (parts.length === 3) {
                                dateB = new Date(parts[2], parts[1] - 1, parts[0]);
                            }
                        }
                        
                        return dateB - dateA; // Orden decreciente
                    });
                    

                    
                    // Agregar filas inv√°lidas al final (sin ordenar)
                    const finalRows = [...validRows, ...invalidRows];
                    
                    // Crear un nuevo array con las filas finales
                    const finalData = [headers, ...finalRows];
                    
                    this.sheetsData[sheetName] = finalData;
                    this.displaySheetData(sheetName);
                    this.displayStats();
                    this.generateAnalysis(finalData);
                    
                } catch (error) {
                    throw new Error('Error al cargar datos de la hoja: ' + error.message);
                }
            }

            generateAnalysis(data) {
                if (!data || data.length < 2) return;
                
                const rows = data.slice(1); // Excluir la fila de headers
                const processors = {};
                const graphics = {};
                const cases = {};
                const combinations = {};

                // √çndices de las columnas
                const priceIndex = 2; // Precio en ‚Ç¨
                const processorIndex = 3; // Procesador
                const graphicsIndex = 4; // Tarjeta gr√°fica
                const caseIndex = 5; // Torre

                rows.forEach(row => {
                    // An√°lisis de procesadores
                    const processorItem = row[processorIndex];
                    if (processorItem && processorItem.trim() !== '') {
                        const cleanProcessor = processorItem.trim();
                        processors[cleanProcessor] = (processors[cleanProcessor] || 0) + 1;
                    }

                    // An√°lisis de tarjetas gr√°ficas
                    const graphicsItem = row[graphicsIndex];
                    if (graphicsItem && graphicsItem.trim() !== '') {
                        const cleanGraphics = graphicsItem.trim();
                        graphics[cleanGraphics] = (graphics[cleanGraphics] || 0) + 1;
                    }

                    // An√°lisis de torres
                    const caseItem = row[caseIndex];
                    if (caseItem && caseItem.trim() !== '') {
                        const cleanCase = caseItem.trim();
                        cases[cleanCase] = (cases[cleanCase] || 0) + 1;
                    }

                    // An√°lisis de combinaciones (procesador + gr√°fica + torre)
                    if (processorItem && graphicsItem && caseItem) {
                        const cleanProcessor = processorItem.trim();
                        const cleanGraphics = graphicsItem.trim();
                        const cleanCase = caseItem.trim();
                        
                        if (cleanProcessor && cleanGraphics && cleanCase) {
                            const combinationKey = `${cleanProcessor}|${cleanGraphics}|${cleanCase}`;
                            combinations[combinationKey] = (combinations[combinationKey] || 0) + 1;
                        }
                    }
                });

                // An√°lisis de precios
                const prices = rows.map(row => parseFloat(row[priceIndex])).filter(p => !isNaN(p));
                const avgPrice = prices.length > 0 ? prices.reduce((a, b) => a + b, 0) / prices.length : 0;
                const minPrice = Math.min(...prices);
                const maxPrice = Math.max(...prices);

                this.displayAnalysis(processors, graphics, cases, { avg: avgPrice, min: minPrice, max: maxPrice, total: rows.length });
                this.displayCombinationsTable(combinations);
            }

            displayAnalysis(processors, graphics, cases, prices) {
                // Crear contenido del an√°lisis
                const analysisContent = document.getElementById('analysis-content');
                
                analysisContent.innerHTML = `
                    <div class="analysis-grid">
                        <div class="processor-section">
                            <h3 class="section-title">
                                Procesadores
                            </h3>
                            ${this.generateAnalysisTable(processors, 'Procesador', 'processor')}
                        </div>
                        
                        <div class="graphics-section">
                            <h3 class="section-title">
                                Tarjetas Gr√°ficas
                            </h3>
                            ${this.generateAnalysisTable(graphics, 'Tarjeta Gr√°fica', 'graphics')}
                        </div>
                        
                        <div class="tower-section">
                            <h3 class="section-title">
                                Torres
                            </h3>
                            ${this.generateAnalysisTable(cases, 'Torre', 'case')}
                        </div>
                    </div>
                    
                    <div class="prices-section">
                        <h3 class="prices-title">
                            Resumen de Precios
                        </h3>
                        <div class="prices-grid">
                            <div class="price-card">
                                <div class="price-value price-avg">${Math.round(prices.avg)}‚Ç¨</div>
                                <div class="price-label">Precio Promedio</div>
                            </div>
                            <div class="price-card">
                                <div class="price-value price-min">${prices.min}‚Ç¨</div>
                                <div class="price-label">Precio M√≠nimo</div>
                            </div>
                            <div class="price-card">
                                <div class="price-value price-max">${prices.max}‚Ç¨</div>
                                <div class="price-label">Precio M√°ximo</div>
                            </div>
                        </div>
                    </div>
                `;
            }

            displayCombinationsTable(combinations) {
                const combinationsContainer = document.getElementById('combinations-table-container');
                
                if (!combinations || Object.keys(combinations).length === 0) {
                    combinationsContainer.innerHTML = '<p class="no-combinations">No hay combinaciones disponibles para mostrar.</p>';
                    return;
                }

                // Convertir combinaciones a array, filtrar las que solo se usaron una vez y ordenar por n√∫mero de veces usado (de mayor a menor)
                const sortedCombinations = Object.entries(combinations)
                    .filter(([, count]) => count > 1) // Solo combinaciones usadas m√°s de una vez
                    .sort(([, countA], [, countB]) => countB - countA)
                    .slice(0, 20); // Mostrar solo las top 20 combinaciones

                let tableHTML = `
                    <div class="analysis-table-container">
                        <table class="combinations-table" style="width: 780px !important; table-layout: fixed !important;">
                            <thead>
                                <tr>
                                    <th style="width: 80px !important; min-width: 80px !important; max-width: 80px !important;">N¬∞ veces</th>
                                    <th style="width: 200px !important; min-width: 200px !important; max-width: 200px !important;">Procesador</th>
                                    <th style="width: 200px !important; min-width: 200px !important; max-width: 200px !important;">Gr√°fica</th>
                                    <th style="width: 300px !important; min-width: 300px !important; max-width: 300px !important;">Torre</th>
                                </tr>
                            </thead>
                            <tbody>
                `;

                sortedCombinations.forEach(([combinationKey, count], index) => {
                    const [processor, graphics, case_] = combinationKey.split('|');
                    const rowClass = index % 2 === 0 ? 'combinations-row combinations-row-even' : 'combinations-row combinations-row-odd';
                    
                    tableHTML += `
                        <tr class="${rowClass}">
                            <td class="combinations-count" style="width: 80px !important; min-width: 80px !important; max-width: 80px !important; text-align: center !important;">${count}</td>
                            <td class="combinations-processor" style="width: 200px !important; min-width: 200px !important; max-width: 200px !important; text-align: center !important;">${processor}</td>
                            <td class="combinations-graphics" style="width: 200px !important; min-width: 200px !important; max-width: 200px !important; text-align: center !important;">${graphics}</td>
                            <td class="combinations-case" style="width: 300px !important; min-width: 300px !important; max-width: 300px !important; text-align: center !important;">${case_}</td>
                        </tr>
                    `;
                });

                tableHTML += '</tbody></table></div>';
                
                combinationsContainer.innerHTML = tableHTML;
            }

            generateAnalysisTable(data, title, type) {
                const sortedData = Object.entries(data)
                    .sort(([nameA, countA], [nameB, countB]) => {
                        if (countB !== countA) {
                            return countB - countA; // Primero por cantidad (de mayor a menor)
                        }
                        return nameA.localeCompare(nameB); // Luego alfab√©ticamente en empates
                    });

                let tableHTML = `
                    <div class="analysis-table-container">
                        <table class="analysis-table">
                            <thead>
                                <tr>
                                    <th>${title}</th>
                                    <th>N¬∞ veces</th>
                                    <th>%</th>
                                </tr>
                            </thead>
                            <tbody>
                `;

                const total = Object.values(data).reduce((sum, count) => sum + count, 0);

                sortedData.forEach(([name, count], index) => {
                    const percentage = ((count / total) * 100).toFixed(1);
                    const rowClass = index % 2 === 0 ? 'analysis-row analysis-row-even' : 'analysis-row analysis-row-odd';
                    
                    tableHTML += `
                        <tr class="${rowClass}">
                            <td>${name}</td>
                            <td>${count}</td>
                            <td>${percentage}%</td>
                        </tr>
                    `;
                });

                tableHTML += '</tbody></table></div>';
                
                // Agregar resumen del total de componentes distintos
                const uniqueComponents = Object.keys(data).length;
                const totalUsage = total;
                
                tableHTML += `
                    <div class="analysis-summary">
                        <span class="analysis-summary-text">${uniqueComponents} componentes distintos</span> | 
                        <span class="analysis-summary-text">Cantidad total: ${totalUsage}</span>
                    </div>
                `;
                

                
                return tableHTML;
            }







            setupEventListeners() {
                document.getElementById('go-to-analysis-btn').onclick = () => this.showAnalysis();
                document.getElementById('back-to-data-btn').onclick = () => this.showData();
                document.getElementById('back-to-data-btn-bottom').onclick = () => this.showData(); // Add listener for the new button
            }

            showAnalysis() {
                // Asegurar que el an√°lisis est√© generado
                if (this.sheetsData['Datos'] && this.sheetsData['Datos'].length > 1) {
                    this.generateAnalysis(this.sheetsData['Datos']);
                }
                
                // OCULTAR COMPLETAMENTE la secci√≥n de datos y estad√≠sticas
                document.getElementById('data-container').style.display = 'none';
                document.getElementById('stats-info').style.display = 'none';
                
                // MOSTRAR SOLO la secci√≥n de an√°lisis
                document.getElementById('analysis-container').style.display = 'block';
                document.getElementById('analysis-container').classList.remove('hidden');
                
                // Desplazarse al inicio de la p√°gina
                setTimeout(() => {
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                }, 100);
                
                // Alternativa si el scroll suave no funciona
                setTimeout(() => {
                    if (window.pageYOffset > 0) {
                        window.scrollTo(0, 0);
                    }
                }, 500);
            }

            showData() {
                // OCULTAR la secci√≥n de an√°lisis
                document.getElementById('analysis-container').style.display = 'none';
                document.getElementById('analysis-container').classList.add('hidden');
                
                // MOSTRAR la secci√≥n de datos y estad√≠sticas
                document.getElementById('data-container').style.display = 'block';
                document.getElementById('stats-info').style.display = 'block';
                
                // Desplazarse arriba del todo - FORZAR el scroll
                setTimeout(() => {
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                }, 100);
                
                // Alternativa si el scroll suave no funciona
                setTimeout(() => {
                    if (window.pageYOffset > 0) {
                        window.scrollTo(0, 0);
                    }
                }, 500);
            }



            showLoading(message) {
                document.getElementById('loading').innerHTML = `‚è≥ ${message}`;
                document.getElementById('loading').style.display = 'block';
            }

            hideLoading() {
                document.getElementById('loading').style.display = 'none';
            }

            showError(message) {
                document.getElementById('loading').style.display = 'none';
                document.getElementById('error').textContent = message;
                document.getElementById('error').classList.remove('hidden');
            }

            displayStats() {
                const data = this.sheetsData['Datos'];
                if (!data || data.length < 2) return;

                const totalRows = data.length - 1; // Excluir headers
                const uniqueProcessors = new Set();
                const uniqueGraphics = new Set();
                const uniqueCases = new Set();

                // Contar componentes distintos
                data.slice(1).forEach(row => {
                    if (row[3] && row[3].trim()) uniqueProcessors.add(row[3].trim());
                    if (row[4] && row[4].trim()) uniqueGraphics.add(row[4].trim());
                    if (row[5] && row[5].trim()) uniqueCases.add(row[5].trim());
                });

                const statsGrid = document.getElementById('stats-grid');
                statsGrid.innerHTML = `
                    <div class="stat-card">
                        <div class="number">${totalRows}</div>
                        <div class="label">Montajes</div>
                    </div>
                    <div class="stat-card">
                        <div class="number">${uniqueProcessors.size}</div>
                        <div class="label">Procesadores distintos</div>
                    </div>
                    <div class="stat-card">
                        <div class="number">${uniqueGraphics.size}</div>
                        <div class="label">Tarjetas Gr√°ficas distintas</div>
                    </div>
                    <div class="stat-card">
                        <div class="number">${uniqueCases.size}</div>
                        <div class="label">Torres distintas</div>
                    </div>
                `;

                document.getElementById('stats-info').classList.remove('hidden');
                document.getElementById('data-container').style.display = 'block';
            }

            displaySheetData(sheetName) {
                const data = this.sheetsData[sheetName];
                if (!data || data.length === 0) {
                    document.getElementById('table-container').innerHTML = '<p>No hay datos en esta hoja.</p>';
                    return;
                }

                const headers = data[0];
                const rows = data.slice(1);

                let tableHTML = '<table class="data-table"><thead><tr>';
                headers.forEach((header, headerIndex) => {
                    const isLastColumn = headerIndex === headers.length - 1;
                    const isPenultimateColumn = headerIndex === headers.length - 2;
                    
                    if (headerIndex === 0) { // Columna de Fecha
                        tableHTML += `<th>`;
                        tableHTML += '<div class="date-nav-buttons">';
                        tableHTML += '<button onclick="scrollToFirstRow()" class="date-nav-button" title="Ir a la fecha m√°s reciente">‚ñ≤</button>';
                        tableHTML += '<button onclick="scrollToLastRow()" class="date-nav-button" title="Ir a la fecha m√°s antigua">‚ñº</button>';
                        tableHTML += '</div>';
                        tableHTML += header;
                        tableHTML += '</th>';
                    } else if (headerIndex === 1) { // Segunda columna - T√≠tulo del directo de Twitch
                        tableHTML += `<th>${header}</th>`;
                    } else if (isLastColumn) { // √öltima columna sin borde
                        tableHTML += `<th>${header}</th>`;
                    } else if (headerIndex === 2) { // Tercera columna - Precio en ‚Ç¨
                        tableHTML += `<th>${header}</th>`;
                    } else if (headerIndex === 3) { // Cuarta columna - Procesador
                        tableHTML += `<th>${header}</th>`;
                    } else if (headerIndex === 4) { // Quinta columna - Tarjeta gr√°fica
                        tableHTML += `<th>${header}</th>`;
                    } else { // Otras columnas
                        tableHTML += `<th>${header}</th>`;
                    }
                });
                tableHTML += '</tr></thead><tbody>';

                rows.forEach((row, index) => {
                    tableHTML += '<tr>';
                    headers.forEach((header, cellIndex) => {
                        const cellValue = row[cellIndex] || '';
                        
                        // Center align specific columns
                        if (cellIndex === 0 || cellIndex === 2) { // Date and Price columns
                            tableHTML += `<td class="data-cell data-cell-center">${cellValue}</td>`;
                        } else {
                            tableHTML += `<td class="data-cell">${cellValue}</td>`;
                        }
                    });
                    tableHTML += '</tr>';
                });

                tableHTML += '</tbody></table>';
                document.getElementById('table-container').innerHTML = tableHTML;
            }
        }

        // Funci√≥n global para scroll a la primera fila
        function scrollToFirstRow() {
            const tableContainer = document.getElementById('table-container');
            const table = tableContainer.querySelector('table');
            
            if (table) {
                const tbody = table.querySelector('tbody');
                if (tbody && tbody.rows.length > 0) {
                    const firstRow = tbody.rows[0];
                    firstRow.scrollIntoView({ 
                        behavior: 'smooth', 
                        block: 'center' 
                    });
                    
                    // Resaltar brevemente la fila
                    firstRow.style.backgroundColor = '#e3f2fd';
                    setTimeout(() => {
                        firstRow.style.backgroundColor = '';
                    }, 2000);
                }
            }
        }

        // Funci√≥n global para scroll a la √∫ltima fila
        function scrollToLastRow() {
            const tableContainer = document.getElementById('table-container');
            const table = tableContainer.querySelector('table');
            
            if (table) {
                const tbody = table.querySelector('tbody');
                if (tbody && tbody.rows.length > 0) {
                    const lastRow = tbody.rows[tbody.rows.length - 1];
                    lastRow.scrollIntoView({ 
                        behavior: 'smooth', 
                        block: 'center' 
                    });
                    
                    // Resaltar brevemente la fila
                    lastRow.style.backgroundColor = '#e3f2fd';
                    setTimeout(() => {
                        lastRow.style.backgroundColor = '';
                    }, 2000);
                }
            }
        }

        // Inicializar la aplicaci√≥n cuando se carga la p√°gina
        document.addEventListener('DOMContentLoaded', () => {
            new PCBuildsViewer();
        });
    </script>
</body>
</html>

